<tei>
    <teiHeader>
        <fileDesc xml:id="_TUW-200745.pdf"/>
    </teiHeader>
    <text xml:lang="en">


		<figure type="table">

            <head>ii<lb/> </head>
<lb/> 
            <table>Kurzfassung<lb/> iii<lb/> Abstract<lb/> iv<lb/> Inhaltsverzeichnis<lb/> v<lb/> 1 Einleitung<lb/> 1<lb/> 1.1 Generalized Minimum Spanning Tree-Problem . . . . . . . . . . . . .<lb/> 1<lb/> 1.2 Evolutionäre Algorithmen . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 2<lb/> 1.3 Lösungsarchive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 3<lb/> 1.4 Lösungsrepräsentationen . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 4<lb/> 1.4.1 Gosh-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 5<lb/> 1.4.2 Pop-Kodierung . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 5<lb/> 1.5 Branch and Bound . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 6<lb/> 1.6 Bisherige Ansätze . . . . . . . . . . . . . . . . . . . . . . . . . . . . .<lb/> 7<lb/> 1.6.1 EA mit Gosh-Lösungsarchiv . . . . . . . . . . . . . . . . . . .<lb/> 8<lb/> 1.6.2 EA mit Pop-Lösungsarchiv . . . . . . . . . . . . . . . . . . . . 10<lb/> 2 Algorithmus<lb/> 12<lb/> 2.1 Boundberechnung im Gosh-Archiv . . . . . . . . . . . . . . . . . . . . 13<lb/> 2.1.1 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 15<lb/> 2.1.2 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 17<lb/> 2.2 Boundberechnung im Pop-Archiv . . . . . . . . . . . . . . . . . . . . . 19<lb/> 2.2.1 Inkrementelle Boundberechnung . . . . . . . . . . . . . . . . . 23<lb/> 2.2.2 Pop mit Nearest Neighbours Reduktion . . . . . . . . . . . . . 24<lb/> 2.2.3 Einfüge-Methode . . . . . . . . . . . . . . . . . . . . . . . . . 26<lb/> 2.2.4 Konvertierungs-Methode . . . . . . . . . . . . . . . . . . . . . 27<lb/> 3 Ergebnisse<lb/> 30<lb/> 3.1 Vorgehensweise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30<lb/> v 3.2 Tests mit fixer Laufzeit . . . . . . . . . . . . . . . . . . . . . . . . . . 31<lb/> 3.2.1 Analyse der Cuts . . . . . . . . . . . . . . . . . . . . . . . . . 31<lb/> 3.2.2 Gosh-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . 33<lb/> 3.2.3 Nearest Neighbours . . . . . . . . . . . . . . . . . . . . . . . . 34<lb/> 3.2.4 Pop-Archiv . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36<lb/> 3.2.5 Beide Archive . . . . . . . . . . . . . . . . . . . . . . . . . . . 37<lb/> 3.3 Fixe Anzahl von Generationen . . . . . . . . . . . . . . . . . . . . . . 39<lb/> 3.4 State of the Art . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43<lb/> 4 Zusammenfassung<lb/> 45<lb/> Literaturverzeichnis<lb/> 47<lb/> vi Einleitung<lb/> 1.1 Generalized Minimum Spanning Tree-Problem<lb/> Das Generalized Minimum Spanning Tree-Problem (GMST) ist ein kombinatorisches<lb/> Optimierungsproblem, das eine Verallgemeinerung des Minimum Spanning Tree Prob-<lb/>lems (MST) ist. Für das MST-Problem ist ein vollständiger Graph G gegeben, bei<lb/> dem jeder Kante Kosten zugeordnet sind. Eine Lösung des MST-Problems entspricht<lb/> einer Teilmenge von Kanten, die einen minimalen Spannbaum bilden. Ein minimaler<lb/> Spannbaum ist ein kreisfreier Teilgraph von G, der mit allen Knoten des Graphen ver-<lb/>bunden ist und dessen Summe der Kantenkosten minimal ist. Beim GMST-Problem<lb/> werden zusätzlich noch die Knoten des MST-Problems durch Cluster partitioniert.<lb/> Die formale Definition des GMST-Problems sieht wie folgt aus [4]:</table>
		</figure>


		<figure type="table">

            <table>Bei einem EA werden neue Lösungen durch Kombination von alten Lösungen, die sich<lb/> in der Population befinden, erzeugt. Das kann dazu führen, dass eine neu generierte Lö-<lb/>sung sich schon in der Population befindet bzw. früher schon einmal untersucht wurde.<lb/> Daraus können sich zwei Probleme ergeben. Zum einen führt es dazu, dass die sel-<lb/>ben Lösungen mehrmals evaluiert werden und somit unnötig Laufzeit verbraucht wird,<lb/> da die erneute Evaluierung keinen Sinn macht. Zum anderen kann das mehrfache be-<lb/>trachten der selben Lösungen zu einem Diversitätsverlust führen, d.h. dass sich die<lb/> Lösungen in der Population nach kurzer Zeit kaum mehr unterscheiden. Das führt dazu,<lb/> dass der Lösungsraum nicht mehr so breit durchsucht wird und man so auch schneller<lb/> in einem lokalen Optimum hängen bleibt.<lb/> Um diesen Problemen entgegen zu wirken, sollte bei jeder generierten Lösung überprüft<lb/> werden, ob diese in früheren Generationen schon einmal erzeugt worden ist. Dazu rei-<lb/>cht es aber nicht die Lösungen mit der aktuellen Population zu vergleichen, da hier nur<lb/> ein kleiner Ausschnitt der bisher untersuchten Lösungen enthalten ist. Daher wird eine<lb/> Speicherstruktur verwendet, die Lösungsarchiv [12] genannt wird, in der jede generierte<lb/> Lösung gespeichert wird und in angemessener Zeit danach gesucht werden kann.<lb/> Das Lösungsarchiv muss drei Eigenschaften erfüllen. Es muss in angemessener Zeit<lb/> überprüft werden können ob eine Lösung im Archiv vorhanden ist. Außerdem soll aus<lb/> einer Lösung, die im Archiv enthalten ist, schnell eine neue Lösung generiert werden<lb/> können, die der alten möglichst ähnlich ist. Zusätzlich sollen die beiden Aufgaben mit<lb/> einem angemessenen Speicherverbrauch realisiert werden. Wie ein Lösungsarchiv in einem EA verwendet wird, ist in Algorithmus 1 dargestellt.<lb/> Dieser Algorithmus wurde aus [13] übernommen.<lb/> Die Frage, welche Datenstruktur sich am besten für ein Lösungsarchiv eignet, wurde<lb/> in den Arbeiten von Zaubzer [16] und Šramko [14] untersucht. Sie haben drei Daten-<lb/>strukturen miteinander verglichen: Hashtabellen, Binärbäume und Tries. Das Einfü-<lb/>gen einer Lösung und auch das Prüfen, ob eine Lösung schon enthalten ist, kann mit<lb/> einer Hashtabelle in O(l) (l entspricht der Länge des Strings) gemacht werden. Das<lb/> Finden einer neuen Lösung kann hingegen im schlimmsten Fall O(2<lb/> l ) Schritte benöti-<lb/>gen. Beim Binärbaum können alle drei Operationen in O(l * log 2 (n)) durchgeführt<lb/> werden. Der Nachteil dieser Datenstruktur ist, dass in jedem Knoten eine vollständige<lb/> Lösung gespeichert wird, was zu einem hohen Speicherverbrauch führt. Bei einem Trie<lb/> können alle Operationen in O(l) ausgeführt werden. Das führt zu dem Ergebnis, dass ein<lb/> Trie die geeignetste Datenstruktur, für die vorhin erwähnten benötigten Eigenschaften,<lb/> ist.<lb/> Algorithmus 1 EA mit Lösungsarchiv<lb/> 1: generate random population pop and insert into archiv<lb/> 2: while termination condition not satisfied do<lb/> 3:<lb/> parent1 ← selection(pop)<lb/> 4:<lb/> parent2 ← selection(pop)<lb/> 5:<lb/> sol new ← recombination(parent1, parent2)<lb/> 6:<lb/> mutation(sol new )<lb/> 7:<lb/> lokaleImprovement(sol new )<lb/> 8:<lb/> 9:<lb/> if sol new included in archiv then<lb/> 10:<lb/> convert sol new to new solution<lb/> 11:<lb/> end if<lb/> 12:<lb/> insert sol new into archiv<lb/> 13:</table>
		</figure>


		<figure type="table">

            <table>Mit der Abgrenzung (Bound) wird versucht, Bereiche im Entscheidungsbaum<lb/> schon früh als schlecht zu erkennen und diese Bereiche somit nicht weiter zu<lb/> verfolgen, d.h. es werden schlechte Lösungen schon vorzeitig erkannt. Dazu<lb/> werden zwei Schranken definiert. Eine untere und eine obere Schranke. Bei<lb/> einem Minimierungsproblem entspricht die obere Schranke einer zulässigen Lö-<lb/>sung während die untere Schranke dem Weg von der Wurzel des Entscheidungs-<lb/>baums bis zum aktuellen Teilproblem entspricht. Ist nun die untere Schranke<lb/> schlechter (größer) als die obere Schranke, wird dieser Teil des Entscheidungs-<lb/>baums nicht weiter verfolgt. Falls sie kleiner als die obere Schranke ist, erfolgt<lb/> ein weiterer Verzweigungsschritt. Ist die untere Schranke eine zulässige Lösung<lb/> und ist sie besser als die aktuelle obere Schranke, so wird die untere Schranke die<lb/> neue obere Schranke.<lb/> Wie das Branch and Bound Verfahren in dieser Arbeit verwendet wurde, wird in Kapitel<lb/> 2 näher erläutert.<lb/> 6 Myung, Lee und Tcha [8] haben in ihrer Arbeit das erste Mal das GMST-Problem for-<lb/>mal definiert und haben auch gezeigt dass das Problem NP-schwierig ist.<lb/> Es gibt einige exakte Algorithmen, die aber nur Lösungen für relativ kleine Instanzen<lb/> liefern. In [8] wurde ein exakter Algorithmus verwendet mit mehreren Integer Linear<lb/> Programming-Formulierungen und Branch and Bound Verfahren. Pop hat in [11] eine<lb/> etwas effizientere Mixed Integer Linear Programming-Formulierung verwendet. Damit<lb/> konnten Instanzen mit bis zu 240 Knoten mit 30 Clustern oder 160 Knoten mit 40 Clus-<lb/>tern optimal gelöst werden. In [1] wurde ein Branch and Cut Algorithmus verwendet.<lb/> Um größere Instanzen zu lösen, müssen Metaheuristiken verwendet werden. Eine Meta-<lb/>heuristik ist ein Algorithmus bei dem nicht garantiert werden kann, dass eine optimale<lb/> Lösung gefunden wird. Man sucht vielmehr eine Lösung, die sich der optimalen Lösung<lb/> so gut wie möglich annähert. Eine Methaheuristik wird so definiert, dass sie von den<lb/> Optimierungsproblemen unabhängig sind. Eine auf ein bestimmtes Optimierungspro-<lb/>blem zugeschnittenes Verfahren wird dann Heuristik genannt.<lb/> Für das GMST-Problem wurden auch einige Metaheuristiken angewandt. Gosh [2] hat<lb/> in seiner Arbeit einige Metaheuristik-Ansätze umgesetzt, die auf Tabusuche, Variable<lb/> Neighborhood Descent und Variable Neighborhood Search basieren. Hu, Leitner und<lb/> Raidl [3] haben in ihrer Arbeit einen Variable Neighborhood Search Ansatz entwick-<lb/>elt, der auf den Ansätzen von Gosh [2] und Pop [11] basieren. In [4] haben sie diesen<lb/> Ansatz durch eine zusätzliche Nachbarschaft, die Teillösungen mittels Mixed Integer<lb/> Programming optimiert, erweitert und damit recht gute Ergebnisse erzielt.<lb/> Wolf [15] und Sonnleitner [13] haben in ihren Arbeiten einen EA mit Lösungsarchiv<lb/> verwendet, wobei sie unterschiedliche Lösungsarchive angewendet haben. Wolf hat das<lb/> Archiv auf Basis der Gosh-Kodierung erzeugt, während Sonnleitner ein Archiv auf Ba-<lb/>sis der Pop-Kodierung verwendet hat. Außerdem hat Sonnleitner in seiner Arbeit noch<lb/> eine Variante entwickelt, die beide Archive gleichzeitig verwendet.<lb/> Wolf und Sonnleitner haben mit ihren Ansätzen beide Verbesserungen im Vergleich<lb/> zu einem normalen EA erreicht. Wobei Sonnleitner mit der Variante, in der er beide<lb/> Archive gleichzeitig verwendet, die besten Ergebnisse erzielt hat. Die Ergebnisse dieser<lb/> beiden Arbeiten wurden dann in der Arbeit [5] zusammengefasst und veröffentlicht.<lb/> Da in dieser Arbeit die beiden Archive von Wolf und Sonnleitner als Ausgangspunkt<lb/> genommen wurden und durch ein Bounding Strategie basierend auf einem Branch and<lb/> Bound Verfahren erweitert wurden, wird in den nächsten beiden Kapiteln auf die beiden<lb/> Ansätze nochmal genauer eingegangen. 1.6.1 EA mit Gosh-Lösungsarchiv<lb/> Wie vorher schon erwähnt, hat Wolf [15] in seiner Arbeit das Lösungsarchiv auf Basis<lb/> der Gosh-Kodierung aufgebaut. Bei der Gosh-Kodierung wird, wie in Kapitel 1.4.1 be-<lb/>reits beschrieben, eine Lösung durch einen Vektor repräsentiert, bei dem jedes Element<lb/> einem Cluster entspricht, in dem gespeichert ist, welcher Knoten im Cluster ausgewählt<lb/> wurde.<lb/> Abb. 3: Lösung &lt;321112&gt; im Gosh-Lösungsarchiv eingefügt<lb/> Das Gosh-Lösungsarchiv ist ein Trie, bei dem jede Ebene einem Cluster V i entspricht.<lb/> Jeder Trie-Knoten enthält d i Pointer, d.h. für jeden Knoten im Cluster gibt es einen<lb/> Pointer. Die Pointer können folgende Zustände annehmen:</table>
		</figure>


		<figure type="table">

            <table>normaler Pointer: Pointer zum nächsten Trie-Knoten.<lb/> Abb. 3 zeigt ein Beispiel wie ein Lösungsarchiv nach dem Einfügen einer Lösung<lb/> aussieht. In diesem Beispiel sind zwei Lösungen in dem Archiv bereits enthalten. Die<lb/> Lösung &lt;321112&gt; wurde dem Archiv neu hinzugefügt. Wie in Kapitel 1.3 beschrieben<lb/> werden für ein Lösungsarchiv zwei Funktionen benötigt. Eine Konvertierungs-und eine<lb/> Einfüge-Methode.<lb/> 8<lb/> 1.6. Bisherige Ansätze<lb/> Einfügen einer Lösung<lb/> Beim Einfügen einer Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer<lb/> des Trie-Knoten gefolgt, der dem Knoten aus dem jeweiligen Cluster in der Lösung<lb/> entspricht. Ist der Pointer null, wird ein neuer Trie-Knoten erzeugt und der Pointer wird<lb/> auf diesen neuen Knoten gesetzt. Wenn er complete ist, wurde die Lösung früher schon<lb/> einmal eingefügt und es kann abgebrochen werden. In diesem Fall wird im nächst-<lb/>en Schritt die Konvertierungs-Methode aufgerufen. Bei einer erfolgreichen Einfüge-<lb/>Operation, wird im untersten Trie-Knoten der jeweilige Pointer complete gesetzt. Da-<lb/>nach wird untersucht, ob es entlang der Lösung Teilbäume im Archiv gibt, die voll-<lb/>ständig untersucht wurden. Dazu wird beginnend in der untersten Ebene geprüft, ob<lb/> alle Pointer im Trie-Knoten complete sind. Wenn das der Fall ist, kann der Trie-Knoten<lb/> gelöscht werden und der dazugehörige Pointer im Eltern-Knoten auf complete gesetzt<lb/> werden. Diese Überprüfung erfolgt, beginnend bei dem untersten Trie-Knoten bis zur<lb/> Wurzel, für alle Trie-Konten entlang der Lösung.<lb/> Konvertieren einer Lösung<lb/> Um aus einer Lösung im Trie eine neue Lösung zu generieren, werden zunächst jene<lb/> Trie-Knoten ermittelt, die für eine Änderung in Frage kommen. Das sind jene Trie-<lb/>Knoten entlang der Lösung im Archiv, die nicht in einem als complete markierten<lb/> Bereich liegen. Danach wird aus diesen Trie-Knoten einer zufällig ausgewählt, indem<lb/> dann die Änderungen gemacht werden sollen. In diesem Trie-Knoten wird nach einem<lb/> null-Pointer gesucht. Wenn ein solcher null-Pointer vorhanden ist, wird die Lösung<lb/> dementsprechend abgeändert. Gibt es keinen, geht man im Trie entlang der Lösung<lb/> zum nächsten Trie-Knoten und wiederholt die Suche. Ist der Pointer der Lösung aber<lb/> complete wird ein anderer Pointer ausgewählt und zu diesem Trie-Knoten weiter gegan-<lb/>gen.<lb/> Die Frage welche Ebene im Archiv welchem Cluster zugeordnet wird, wurde in [15]<lb/> näher betrachtet. Wenn die Trie-Knoten der i-ten Ebene im Archiv dem Cluster V i zu-<lb/>geordnet werden, kommt es zu einem Problem. Es entsteht ein so genanntes Bias im<lb/> Trie, d.h. die Wahrscheinlichkeit einer Lösungsänderung in einem Cluster ist nicht für<lb/> alle Cluster gleich groß. Die Knoten in den unteren Ebenen des Archivs haben eine<lb/> größere Chance verändert zu werden. Um dieses Problem zu umgehen, hat Wolf [15]<lb/> in seiner Arbeit eine zufällige Zuteilung der Cluster zu den Trie-Knoten verwendet,<lb/> d.h. beim Erstellen eines neuen Trie-Knoten, wird diesem zufällig ein Cluster zugeord-<lb/>net. Das hat zur Folge, dass nicht mehr einige Cluster bei der Veränderung der Lösung<lb/> bevorzugt werden. 1.6.2 EA mit Pop-Lösungsarchiv<lb/> Abb. 4: Lösung &lt;-65611&gt; im Pop-Lösungsarchiv eingefügt, V 1 ist Wurzelcluster<lb/> Wie vorher schon erwähnt, hat Sonnleitner [13] in seiner Arbeit das Lösungsarchiv auf<lb/> Basis der Pop-Kodierung aufgebaut. Bei der Pop-Kodierung werden, wie in Kapitel<lb/> 1.4.2 bereits beschrieben, die globalen Kanten zwischen den Clustern berücksichtigt.<lb/> Dabei werden die Vorgänger der Cluster in dem Spannbaum des globalen Graphen, in<lb/> einem Vektor gespeichert.<lb/> Das Pop-Lösungsarchiv ist ein Trie, der aus m − 1 Ebenen besteht, wobei jede Trie-<lb/>Ebene für ein Cluster steht. Außer für den Wurzelknoten, da dieser keinen Vorgänger<lb/> hat. In jedem Trie Knoten gibt es m − 1 Pointer, da ein Cluster in einem Baum nicht<lb/> sein eigener Vorgänger sein kann. In Abb. 4 ist ein Beispiel zu sehen, wie eine Lösung<lb/> in einem Pop-Lösungsarchiv gespeichert wird. In diesem Beispiel sind zwei Lösungen<lb/> in dem Archiv schon enthalten. Die Lösung &lt;-65611&gt; wurde dem Archiv neu hinzuge-<lb/>fügt. Da in dieser Kodierung auch Lösungen dargestellt werden können, die keinen<lb/> Baum darstellen, gibt es in dem Pop-Lösungsarchiv, anders als im Gosh-Archiv, noch<lb/> einen zusätzlichen Pointerzustand, der eine ungültige Lösung markiert.<lb/> Die Pointer können daher folgende Zustände annehmen:</table>
		</figure>


		<figure type="table">

            <table>normaler Pointer: Pointer zum nächsten Trie-Knoten. Einfüge-und Konvertierungs-Funktionen<lb/> Die Einfüge-Funktion läuft im Prinzip genauso ab wie im Gosh-Lösungsarchiv. Der<lb/> einzige Unterschied ist, dass beim Einfügen von neuen Trie-Knoten in den Trie die ver-<lb/>botenen Felder im Trie berechnet werden. Dazu werden in dem aktuellen Trie-Knoten<lb/> alle Cluster mit einem kleineren Index als dem aktuellen Cluster geprüft. Bei diesen<lb/> Clustern wird nun überprüft, ob diese Cluster den aktuellen Cluster als Vorgänger haben.<lb/> Ist das der Fall so kann dieser als forbidden markiert werden. Danach wird rekursiv<lb/> überprüft, ob es bereits hinzugefügte Cluster gibt, dessen Vorgänger der nun verbotene<lb/> Cluster ist. Diese werden ebenfalls als forbidden markiert.<lb/> Die Konvertierungs-Funktion arbeitet im Prinzip genauso wie im Gosh-Lösungsarchiv.<lb/> Der Unterschied ist, dass hier bei jeder neu generierten Lösung nochmal geprüft werden<lb/> muss, ob es einen Zyklus gibt und sie somit keine gültige Lösung ist. Das muss gemacht<lb/> werden, da in der Einfüge-Funktion nicht alle möglichen Zyklen markiert werden kön-<lb/>nen.<lb/> 11<lb/> KAPITEL 2<lb/> Algorithmus<lb/> Zur Implementierung des Algorithmus wird ein Steady State EA gemeinsam mit einem<lb/> Gosh-und einem Pop-Lösungsarchiv verwendet. Die beiden Archive wurden in den<lb/> Arbeiten von Wolf [15] und Sonnleitner [13] bereits implementiert. Diese Archive wer-<lb/>den als Ausgangsposition genommen und durch eine Bounding Strategie basierend auf<lb/> einem Branch and Bound Verfahren erweitert.<lb/> Wie in Kapitel 1.5 bereits beschrieben, besteht das Branch and Bound Verfahren aus<lb/> zwei Schritten, dem Verzweigen (Branch) und dem Abgrenzen (Bound). Der Branch-<lb/>Schritt ergibt sich aus dem Lösungsarchiv. Das Archiv kann im Prinzip als Entschei-<lb/>dungsbaum angesehen werden. In jedem Trie Knoten wird für einen bestimmten Clus-<lb/>ter eine Entscheidung getroffen und somit entstehen dadurch die verschiedenen Teil-<lb/>probleme. Im Gosh-Archiv bestehen die Entscheidungen in den Trie-Knoten aus der<lb/> Auswahl eines Knoten innerhalb eines Clusters, während im Pop-Archiv entschieden<lb/> wird, welchen Vorgänger der Cluster in dem Spannbaum hat. Für den Bound-Schritt<lb/> muss eine untere und eine obere Schranke definiert werden. Als obere Schranke wird<lb/> immer die bisher beste Lösung, die vom Evolutionären Algorithmus gefunden wurde,<lb/> genommen. Die untere Schranke wird in den einzelnen Trie-Knoten berechnet. Wie die<lb/> Berechnung genau erfolgt, wird in den Kapiteln 2.1 und 2.2 erläutert. Falls hier eine<lb/> untere Schranke gefunden wird, die größer als die beste bisher gefundene Lösung ist,<lb/> kann dieser Teil des Lösungsarchivs als complete markiert werden. Im weiteren Verlauf<lb/> des Algorithmus werden diese Lösungen schon als besucht erkannt und somit im EA<lb/> nicht mehr berücksichtigt.<lb/> Es gibt prinzipiell zwei Möglichkeiten wann eine Bound berechnet wird. Zum einen<lb/> beim Einfügen der Lösung im Lösungsarchiv und zum anderen beim Konvertieren einer<lb/> schon eingefügten Lösung zu einer neuen. In dieser Arbeit werden beide Varianten untersucht und auch miteinander kombiniert.<lb/> 2.1 Boundberechnung im Gosh-Archiv<lb/> Die Boundberechnung erfolgt immer für einen bestimmten Pointer in einem Trie-Knoten.<lb/> Bei der Gosh-Kodierung wird, wie in Kapitel 1.4.1 bereits erläutert, für jeden Cluster<lb/> gespeichert, welcher Knoten in dem Cluster ausgewählt wurde. Soll in einem bestimmt-<lb/>en Trie-Knoten die Bound berechnet werden, bedeutet das, dass für alle Cluster vom<lb/> aktuellen Trie-Knoten bis hin zur Wurzel schon eine Auswahl der Knoten in den Clus-<lb/>tern getroffen wurde. Für alle Cluster in den darunterliegenden Trie-Ebenen wurde noch<lb/> keine Auswahl getroffen.<lb/> Es ergeben sich also zwei Arten von Clustern. V<lb/> 1 ist die Menge der Cluster für die<lb/> bereits eine Knotenauswahl getroffen wurde und V<lb/> 0 ist die Menge der Cluster für die<lb/> noch keine Auswahl getroffen wurde.<lb/> Um in einem bestimmten Trie-Knoten eine Bound zu berechnen, wird zunächst der</table>
		</figure>


		<figure type="table">

            <table>). Die Berechnung<lb/> des Spannbaums erfolgt mit einem Kruskal Algorithmus mit Union-Find. Die Laufzeit<lb/> dieses Algorithmus wird durch das Sortieren der Kanten bestimmt. Da der Graph G<lb/> ein<lb/> vollständiger Graph ist, entspricht die Anzahl der Kanten |E| = m * (m − 1). Dadurch<lb/> ergibt sich eine Laufzeit von O(m<lb/> 2 log(m<lb/> 2 )) für die Berechnung der Bound. Abb. 5: Boundberechnung im Cluster V 3 beim Einfügen der Lösung &lt;321112&gt;<lb/> In Abb. 5 wird illustriert wie eine Boundberechnung im Gosh-Lösungsarchiv funk-<lb/>tioniert. In diesem Beispiel wird im Trie-Knoten des Cluster V 3 die Bound berechnet.<lb/> An dieser Position wurden die Cluster V 1 , V 2 und V 3 schon in den oberen Ebenen einge-<lb/>fügt und somit eine Knotenauswahl für die Cluster getroffen. In den darunter liegenden<lb/> Clustern (V 4 , V 5 und V 6 ) wurde noch keine Auswahl getroffen. Für die Boundberech-<lb/>nung bedeutet das, dass hier zwischen den Clustern V 1 , V 2 und V 3 als Kantenkosten<lb/> der Abstand der ausgewählten Knoten genommen wird. Zwischen dem Cluster V 3 und<lb/> V 4 wird als Kosten der Distanzen zwischen dem ausgewählten Knoten 1 (V 3 ) und dem<lb/> Knoten 3 (V 4 ) genommen, da dieser die geringste Distanz zum Knoten 1 (V 3 ) hat. Zwi-<lb/>schen den Clustern V 4 , V 5 und V 6 werden die minimalen Distanzen zwischen den Clus-<lb/>tern verwendet. D.h. zwischen Cluster V 6 und V 4 wird die Kante zwischen Knoten 2<lb/> (V 6 ) und Knoten 1 (V 4 ) genommen und zwischen V 5 und V 4 wird die Kante zwischen<lb/> Knoten 1 (V 5 ) und Knoten 4 (V 4 ) genommen.<lb/> Ist die berechnete Bound schlechter als die beste bisher gefundene Lösung, kann der<lb/> Pointer 1 des Clusters V 3 als complete markiert werden. Das kann gemacht werden,<lb/> da zwischen den Clustern V 4 , V 5 und V 6 immer der minimale Abstand genommen<lb/> wurde</table>

            <figDesc>. Wenn nun Knoten in den Clustern ausgewählt werden, bleiben die Kosten des<lb/> Spannbaums gleich oder werden größer aber sie werden sicher nicht kleiner. Das führt<lb/> dazu, dass alle Lösungen in diesem Subtrie mindestens so groß sind als die berechnete<lb/> Bound und somit in diesem Fall auch größer sind als die beste bisher gefundene Lösung. </figDesc>
 
            <table>Wie vorhin schon erwähnt, ist eine Möglichkeit, wann die Boundberechnung durchge-<lb/>führt werden kann, die Einfüge-Operation des Lösungsarchivs. Beim Einfügen einer<lb/> Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt,<lb/> der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Bei einer erfolg-<lb/>reichen Einfüge-Operation werden also m Trie-Knoten durchlaufen. Eine Möglichkeit<lb/> wäre, in jedem dieser m Trie-Knoten für den jeweiligen Pointer, der dem ausgewählten<lb/> Knoten dieses Clusters in der Lösung entspricht, die Bound zu berechnen.<lb/> Das führt aber zu einem Problem. Die Berechnung der Bound hat eine Laufzeit von<lb/> O(m<lb/> 2 log(m<lb/> 2 )). Wenn in jedem Trieknoten die Bound berechnet wird, müsste die<lb/> Bound m-mal ermittelt werden. Das würde zu einer Laufzeit von O(m<lb/> 3 log(m<lb/> 2 ))<lb/> führen, was eine erhebliche Verschlechterung gegenüber der normalen Einfüge-Operation<lb/> ohne Boundberechnung, mit einer Laufzeit von O(m), wäre.<lb/> Eine Möglichkeit dieses Problem abzuschwächen ist es, die Bound nicht in jedem der<lb/> m Trie-Knoten zu berechnen, sondern nur in einer bestimmten Auswahl von Knoten.<lb/> Dazu wurde der Parameter branch_and_bound_prob eingeführt, mit dem angegeben<lb/> werden kann, mit welcher Wahrscheinlichkeit eine Boundberechnung für einen Trie-<lb/>Knoten durchgeführt wird. Als ein guter Wert für diesen Parameter hat sich 0, 05 her-<lb/>ausgestellt. Das bedeutet, es wird für 5% der Trie-Knoten die Bound berechnet. Die<lb/> Auswahl erfolgt dabei zufällig.<lb/> In Algorithmus 2 ist der Pseudocode für die Einfüge-Operation mit Boundberechnung<lb/> dargestellt. Diese beruht auf der Einfüge-Operation von Wolf [15], nur dass diese durch<lb/> die Bounding Strategie erweitert wurde. Zunächst wird der Vektor V<lb/> 0 , in der alle Clus-<lb/>ter gespeichert sind, die noch nicht in das Archiv eingefügt worden sind, initialisiert.<lb/> Ausgehend vom Wurzelknoten wird nun immer dem Pointer des Trie-Knoten gefolgt,<lb/> der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Der Cluster wird<lb/> dabei immer aus dem Vektor V<lb/> 0 entfernt und dem Vektor V<lb/> 1 hinzugefügt, indem alle<lb/> Cluster gespeichert sind die schon eingefügt worden sind. Diese beiden Vektoren wer-<lb/>den dann für die spätere Boundberechnung benötigt. Ist der Pointer gleich null, muss<lb/> ein neuer Trie-Knoten angelegt werden. Dazu wird zufällig ein Cluster aus dem Vektor<lb/> V<lb/> 0 ausgewählt. Danach wird, mithilfe des Parameters branch_and_bound_prob, er-<lb/>mittelt ob für diesen Trie-Knoten eine Bound berechnet werden soll. Wird eine Bound<lb/> berechnet und ist sie schlechter als die beste bisher gefundene Lösung, werden alle<lb/> Trie-Knoten in den darunterliegenden Sub-Trie gelöscht und der Pointer als complete<lb/> markiert. Anschließend wird die Einfüge-Operation abgebrochen und f alse als Rück-Algorithmus 2 GoshTrie insert with Bound<lb/> Eingabe: sol -solution to insert; best solution bestsol<lb/> Ausgabe: insertion successfull (true/false)<lb/> Variablen: m=number of clusters; root=root from archiv<lb/> 1: V<lb/> 0 ← list with all numbers from 0 to m − 1<lb/> 2: curr ← root<lb/> 3: for i = 0...m − 1 do<lb/> 4:<lb/> pos ← sol[curr.cluster]<lb/> 5:<lb/> move cluster curr from V<lb/> 0 to V<lb/> 1<lb/> 6:<lb/> if curr.next[pos] == complete then<lb/> 7:<lb/> return false<lb/> 8:<lb/> end if<lb/> 9:<lb/> if curr.next[pos] == null then<lb/> 10:<lb/> if i == m − 1 then<lb/> 11:<lb/> curr.next[pos] ← complete<lb/> 12:<lb/> end if<lb/> 13:<lb/> rand ← random cluster from V<lb/> 0<lb/> 14:<lb/> V<lb/> 0 ← list with all numbers from 0 to m − 1<lb/> 15:<lb/> curr.next[pos] ← new node with cluster rand<lb/> 16:<lb/> end if<lb/> 17:<lb/> random choice if bound has to be calculated<lb/> 18:<lb/> if bound has to be calculated then<lb/> 19:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 20:<lb/> delete curr.next[pos]<lb/> 21:<lb/> curr.next[pos] ← complete<lb/> 22:<lb/> return f alse<lb/> 23:<lb/> end if<lb/> 24:<lb/> end if<lb/> 25:<lb/> curr ← curr.next[pos]<lb/> 26: end for<lb/> 27: check if there are complete subtrees along sol<lb/> 28: return true<lb/> </table>
<lb/> 
            <figDesc>gabewert zurück gegeben.<lb/> Das hat zur Folge, dass die Lösung so behandelt wird als wäre sie schon einmal einge-<lb/>fügt worden und es wird eine neue Lösung generiert. Wenn das Einfügen erfolgreich<lb/> war, wird von unten nach oben entlang von sol untersucht, ob bei einem Trie-Knoten<lb/> alle Pointer complete sind. Ist das der Fall kann dieser gelöscht werden und der Pointer<lb/> im Eltern Knoten auf complete gesetzt werden.</figDesc>
		</figure>


		<figure type="table">

            <table>6:<lb/> sol[curr.cluster] ← random null-pointer of curr<lb/> 7:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 8:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 9:<lb/> undo changes of sol<lb/> 10:<lb/> else<lb/> 11:<lb/> return true<lb/> 12:<lb/> end if<lb/> 13:<lb/> end if<lb/> 14:<lb/> if curr.next[sol[curr.cluster]]! = complete] then<lb/> 15:<lb/> move curr.next[sol[curr.cluster]].cluster from V<lb/> 0 to V<lb/> 1<lb/> 16:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 17:<lb/> delete curr.next[sol[curr.cluster]]<lb/> 18:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 19:<lb/> else<lb/> 20:<lb/> curr ← curr.next[sol[curr.cluster]]<lb/> 21:<lb/> end if<lb/> 22:<lb/> else<lb/> 23:<lb/> sol[curr.cluster] ← a random not-complete-pointer, of curr<lb/> 24:<lb/> move curr.next[sol[curr.cluster]].cluster from V<lb/> 0 to V<lb/> 1<lb/> 25:<lb/> if bestsol &lt; calculateBound(V<lb/> 1 , V<lb/> 0 ) then<lb/> 26:<lb/> delete curr.next[sol[curr.cluster]]<lb/> 27:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 28:<lb/> undo changes of sol<lb/> 29:<lb/> else<lb/> 30:<lb/> curr ← curr.next[sol[cur.cluster]]<lb/> 31:<lb/> end if<lb/> 32:<lb/> end if<lb/> 33: end while<lb/> 34: return f alse 2.</table>

            <head>2 Boundberechnung im Pop-Archiv<lb/> Die Boundberechnung erfolgt, genauso wie beim Gosh-Archiv auch,</head>
		</figure>


		<figure type="table">

            <figDesc>Abb. 6 wird illustriert, wie so ein Wald aussehen<lb/> kann. Die Abbildung zeigt einen Graph G<lb/> bei einer Boundberechnung im Trie-Knoten<lb/> von Cluster 6.<lb/> Die Berechnung der Bound erfolgt nun in mehreren Schritten. In Algorithmus 4 wird<lb/> in dem Pseudocode gezeigt, wie die Boundberechnung funktioniert. Zunächst wird ein<lb/> Vektor data erzeugt, indem am Ende der Funktion die ausgewählten Knoten in den<lb/> Clustern gespeichert werden. Die Elemente von data werden mit -1 initialisiert.<lb/> Danach wird mit den Methoden calcClusters und generateList durch dynamische<lb/> Programmierung für die einzelnen Bäume von G<lb/> ermittelt, welche Knoten innerhalb<lb/> </figDesc>
<lb/> 
            <table>Abb. 6: Boundberechnung im Cluster V 6 Algorithmus 4 calcBoundByDynProg<lb/> Eingabe: root-node cN r; solution sol; current level of the trie aktP os<lb/> Ausgabe: bound<lb/> Variablen: data = list of the selected nodes of the clusters<lb/> 1: init data with −1<lb/> 2: nextcN r ← cN r<lb/> 3: repeat<lb/> 4:<lb/> calcClusters (nextcN r, sol, data, aktP os)<lb/> 5:<lb/> generateList (nextcN r, data[nextcN r], sol, aktP os)<lb/> 6:<lb/> nextinnerN ode ← next cluster with data[nextinnerN ode] = −1 and<lb/> nextinnerN ode &lt;= aktP os<lb/> 7:<lb/> if it exists a nextinnerN ode then<lb/> 8:<lb/> nextcN r ← getRootNode(sol, nextinnerN ode, aktP os)<lb/> 9:<lb/> end if<lb/> 10: until it exists a nextinnerN ode<lb/> 11: bound ← calculateBound(sol, data, aktP os)<lb/> 12: return bound<lb/> der Cluster ausgewählt werden sollen. Die Knoten werden so ausgewählt, dass die<lb/> Kosten der daraus entstehenden Lösung minimal sind. Begonnen wird dabei mit dem<lb/> Baum der vom Wurzelknoten des Lösungsarchivs ausgeht. Danach wird geprüft, ob es<lb/> noch ein Cluster in C ∈ V<lb/> 1 gibt, für den noch kein Knoten ausgewählt wurde, d.h.<lb/> dessen Eintrag in data noch -1 ist. Falls es so einen Cluster gibt, wird für diesen Cluster<lb/> C der Wurzelknoten des Baums, in dem er sich in G<lb/> befindet, ermittelt. Von diesem<lb/> Wurzelknoten wird nun wieder mit calcClusters und generateList eine Auswahl der<lb/> Knoten für die Cluster des Baums getroffen. Das wird solange wiederholt bis für alle<lb/> Cluster in V<lb/> 1 eine Auswahl getroffen wurde.</table>
		</figure>


		<figure type="table">

            <figDesc>wurde eine Nachbarschaft verwendet, in der die neuen Lösungen inkrementell<lb/> berechnet wurden. Derselbe Ansatz soll auch in dieser Arbeit verwendet werden. Beim<lb/> Einfügen einer Lösung wird an verschiedenen Stellen entlang der Lösung im Trie die<lb/> Bound berechnet. Dabei werden aber für manche Teile der Lösung Berechnungen<lb/> mehrfach durchgeführt. Dasselbe gilt auch für das Berechnen von Bounds bei der Kon-<lb/>vertierung von Lösungen.<lb/> Die Idee der inkrementellen Berechnung ist es, dass bei der ersten Berechnung der<lb/> Bound innerhalb einer Einfüge-bzw. Konvertierungs-Methode die Bound, wie vorhin<lb/> beschrieben, &quot;normal&quot; berechnet wird. Bei den nächsten Berechnungen der Bound<lb/> müssen nicht mehr für alle Teile des Baums die Kosten der Knoten berechnet werden.<lb/> Die Knotenkosten innerhalb eines Clusters V i können sich nur ändern, wenn V i einen<lb/> neuen Nachfolgecluster im Graphen G<lb/> bekommt oder die Kosten eines Nachfolgers<lb/> von V i sich geändert haben.<lb/> Zur Umsetzung der inkrementellen Boundberechnung wurde ein Vektor valid verwen-<lb/>det, indem für jeden Cluster angegeben wird, ob sich die Knotenkosten in den Cluster<lb/> ändern. Die einzige Änderung die, gegenüber der &quot;normalen&quot; Boundberechnung zu<lb/> machen ist, ist in der Methode calcCluster vorzunehmen. In Algorithmus 8 ist zu se-<lb/>hen, wie die geänderte Methode aussieht. In der Methode wird der Vektor valid dazu<lb/> verwendet, um festzustellen, ob die Bound berechnet werden soll oder nicht.<lb/> </figDesc>
<lb/> 
            <table>Algorithmus 8 calcClustersImprove<lb/> Eingabe: root-node cN r; solution sol; data; current level of the trie aktP os<lb/> 1: if !valid[cNr] then<lb/> 2:<lb/> for i=0. . . aktP os do<lb/> 3:<lb/> if sol[i]==cN r then<lb/> 4:<lb/> calcClusters (i, sol, data, aktP os)<lb/> 5:<lb/> end if<lb/> 6:<lb/> end for<lb/> 7:<lb/> calcCluster (cN r, sol, data)<lb/> 8: end if 2.</table>

            <head>2.2 Pop mit Nearest Neighbours Reduktion<lb/> In [10] wurde ein Ansatz verfolgt, indem für die Berechnung eines GTSP sogenannte<lb/> </head>
<lb/> 
            <figDesc>&quot;candidate lists&quot; verwendet wurden, um den Suchraum einzuschränken. Dabei wurden<lb/> für jeden Knoten die n nächsten Nachbarn in einer Liste gespeichert und nur diese als<lb/> mögliche Nachfolger in der Tour betrachtet. Der Ansatz wird auch in dieser Arbeit ver-<lb/>folgt. Dazu wird die Rekombinations-und Mutations-Methode des EAs entsprechend<lb/> angepasst. Außerdem wird in der Konvertierungs-Methode des Pop-Lösungsarchivs die<lb/> Nearest Neighbour Reduktion auch angewendet. Darauf wird später in Kapitel 2.2.4<lb/> genauer eingegangen werden.</figDesc>
		</figure>


		<figure type="table">

            <table>Beide Vorgänger sind in der Menge der Nearest Neighbours von C i : Hier wird<lb/> zufällig einer der beiden ausgewählt.<lb/> Abb. 7: Rekombination von zwei Lösungen<lb/> 24<lb/> 2.</table>

            <head>2. Boundberechnung im Pop-Archiv<lb/> • Beide Vorgänger sind nicht in der Menge der Nearest Neighbours von C i : Hier<lb/> wird ebenfalls einer der beiden zufällig ausgewählt.<lb/> </head>
<lb/> 
            <table>Beim Einfügen eines Clusters wird mittels Union Find überprüft, ob durch das Hinzufü-<lb/>gen des Clusters ein Zyklus entsteht. Ist das der Fall, so wird der Vorgänger der anderen<lb/> Lösung übernommen, d.h. der Cluster an dieser Stelle eingefügt. Führt das auch zu<lb/> einem Zyklus, wird dieser Cluster als nicht eingefügt markiert. Diese markierten Clus-<lb/>ter werden zum Schluss in den Baum hinzugefügt, indem zufällig ein Knoten aus der<lb/> Nearest Neighbours Liste des jeweiligen Clusters ausgewählt wird und er dann an dieser<lb/> Stelle eingefügt wird. Ist es nicht möglich den Cluster an einem Nearest Neighbour<lb/> anzuhängen, ohne einen Zyklus zu erzeugen, wird er zufällig an einer Stelle im Baum<lb/> angehängt. In Abb. 7 ist ein Beispiel für eine solche Rekombination illustriert.<lb/> Mutation<lb/> Wie vorhin schon erwähnt, wurde in der Mutation-Methode der Nearest Neighbours<lb/> Ansatz auch umgesetzt. Dazu wurde die in [13] verwendete Methode als Grundlage<lb/> genommen und durch den Nearest Neighbour Ansatz erweitert.<lb/> In der Mutations-Methode wird an einer zufällig ausgewählten Stelle in der Lösung eine<lb/> Änderung vorgenommen. Der Ablauf der Mutations-Methode ist wie folgt: Zuerst wird<lb/> zufällig ein Cluster C i in der Lösung ausgewählt, dessen Vorgänger geändert werden<lb/> soll. Danach werden alle Nearest Neighbours ermittelt, deren direkten oder indirekten<lb/> Vorgänger nicht C i ist. Im nächsten Schritt wird aus dieser Liste zufällig ein neuer<lb/> Vorgänger ermittelt und in die neue Lösung gespeichert. Gibt es keinen solchen Nearest<lb/> Neighbour, werden mit Hilfe eines Tiefensuche-Algorithmus alle möglichen Cluster,<lb/> deren direkten oder indirekten Vorgänger nicht C i ist, ermittelt. Danach wird aus diesen<lb/> Clustern einer zufällig ausgewählt und als neuer Vorgänger für C i genommen. In Algo-<lb/>rithmus 9 wird gezeigt wie die Mutations-Methode funktioniert.<lb/> Algorithmus 9 mutatePredecessor<lb/> Eingabe: Lösung sol<lb/> 1: mutate ← random cluster<lb/> 2: cand ← nearest neighbours from mutate where mutate is not the direct or indirect<lb/> predeccessor in sol<lb/> 3: if cand.size()! = 0 then<lb/> 4:<lb/> cand ←all cluster where mutate is not the direct or indirect predeccessor in sol<lb/> 5: end if<lb/> 6: pred new ← random element from cand<lb/> 7: </table>
 
            <head>sol[mutate] ← pred new Genau wie beim Gosh-Archiv wird auch beim Pop-Archiv die Bounding Strategie </head>
 
            <table>in<lb/> die Einfüge-Methode integriert. Bei der Pop-Einfüge-Methode wird, wie auch in Kapi-<lb/>tel 2.1.1, die Bound nicht in jedem Einfügeschritt berechnet, sondern nur für einen<lb/> Teil der Trie-Knoten der einzufügenden Lösung. Dazu wird wieder der Parameter<lb/> branch_and_bound_prob verwendet, der angibt mit welcher Wahrscheinlichkeit die<lb/> Bound für einen Trie-Knoten berechnet wird.<lb/> Algorithmus 10 PopTrie insert with Bound<lb/> Eingabe: solution to insert sol; best solution bestsol<lb/> Ausgabe: insertion successfull (true/false)<lb/> Variablen: m=number of clusters; root=root from archiv<lb/> 1: curr ← root<lb/> 2: for i=0...m − 1 do<lb/> 3:<lb/> pos ← sol[curr.cluster]<lb/> 4:<lb/> if curr.next[pos] = complete then<lb/> 5:<lb/> return false<lb/> 6:<lb/> end if<lb/> 7:<lb/> if curr.next[pos] == null then<lb/> 8:<lb/> if i == m − 1 then<lb/> 9:<lb/> curr.next[pos] ← complete<lb/> 10:<lb/> end if<lb/> 11:<lb/> curr.next[pos] ← new trie-node<lb/> 12:<lb/> calculate forbidden pointers<lb/> 13:<lb/> end if<lb/> 14:<lb/> invalidate(i, sol)<lb/> 15:<lb/> if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, i) then<lb/> 16:<lb/> delete curr.next[pos]<lb/> 17:<lb/> curr.next[pos] ← complete<lb/> 18:<lb/> check if trie-nodes are complete<lb/> 19:<lb/> return false<lb/> 20:<lb/> end if<lb/> 21:<lb/> curr ← curr.next[pos]<lb/> 22: end for<lb/> 23: check if trie-nodes are complete<lb/> 24: return true<lb/> Der Ablauf der </table>
 
            <head>Insert-Methode wird in Algorithmus 10 gezeigt. Beim Einfügen einer<lb/> Lösung wird, beginnend beim Wurzelknoten, immer dem Pointer des Trie-Knoten gefolgt,<lb/> der dem Knoten aus dem jeweiligen Cluster in der Lösung entspricht. Ist ein solcher Pointer noch null, wird ein Trie-Knoten erzeugt und an dieser Stelle in den Trie einge-<lb/>fügt. Beim ersten Aufruf der Methode calcBoundByDynP rog wird die Bound mithilfe<lb/> der &quot;normalen&quot; dynamischen Programmierung ermittelt. Für alle weiteren Aufrufe<lb/> </head>
<lb/> 
            <figDesc>der Methode calcBoundByDynP rog innerhalb derselben Einfügeoperation wird die<lb/> inkrementelle Boundberechnung, die in Kapitel 2.2.1 beschrieben wird, verwendet.<lb/> Dazu müssen vorher alle Cluster, für die sich die Kosten der Knoten ändern, markiert<lb/> werden. Deshalb wird vor der Boundberechnung die Methode invalidate aufgerufen.<lb/> In dieser Methode werden alle Cluster, vom aktuellen Cluster bis hin zur Wurzel im<lb/> Spannbaum der Lösung, markiert.</figDesc>
		</figure>


		<figure type="table">

            <label>7</label>

            <head>:<lb/> </head>
<lb/> 
            <table>if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then<lb/> 8:<lb/> curr.next[sol[curr.cluster]] ← complete<lb/> 9:<lb/> undo changes of sol<lb/> 10:<lb/> else<lb/> 11:<lb/> return true<lb/> 12:<lb/> end if<lb/> 13:<lb/> else<lb/> 14:<lb/> if curr.next[sol[curr.cluster]]! = complete] then<lb/> 15:<lb/> invalidate(curr.cluster, sol)<lb/> 16:<lb/> if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then<lb/> 17:<lb/> delete curr.next[sol[curr.cluster]] and set it complete<lb/> 18:<lb/> else<lb/> 19:<lb/> curr ← curr.next[sol[curr.cluster]]<lb/> 20:<lb/> end if<lb/> 21:<lb/> else<lb/> 22:<lb/> sol[curr.cluster] ← random not-complete-pointer from nn[curr], if none<lb/> exist, random not-complete-pointer from all pointer in curr<lb/> 23:<lb/> invalidate(curr.cluster, sol)<lb/> 24:<lb/> if bestsol &lt; calcBoundByDynP rog(root.cluster, sol, curr.cluster) then<lb/> 25:<lb/> delete curr.next[sol[curr.cluster]] and set it complete<lb/> 26:<lb/> undo changes of sol<lb/> 27:<lb/> else<lb/> 28:<lb/> curr ← curr.next[sol[cur.cluster]]<lb/> 29:<lb/> end if<lb/> 30:<lb/> end if<lb/> 31:<lb/> end if<lb/> 32: end while<lb/> 29<lb/> KAPITEL 3<lb/> Ergebnisse<lb/> 3.1 Vorgehensweise<lb/> Die folgenden Tests wurden mit 14 TSPLib-Instanzen<lb/> 1 durchgeführt. Diese Instanzen<lb/> sind ursprünglich für das Traveling Salesman Problem erzeugt worden und wurden für<lb/> das GMST-Problem angepasst. Dazu wurden Cluster der Instanz hinzugefügt und die<lb/> einzelnen Knoten mittels geografischem Clustering zugeordnet. Die verwendeten In-<lb/>stanzen bestehen aus 150-442 Knoten und 30-89 Clustern. Im Schnitt hat also jedes<lb/> Cluster 5 Knoten. Die erweiterten TSPLib-Instanzen wurden auch von Wolf [15] und<lb/> Sonnleitner [13] verwendet, was einen Vergleich der Ergebnisse erleichtert.<lb/> Da der EA ein randomisierter Algorithmus ist, wurden für alle Tests 30 Runs gemacht<lb/> und für die Auswertung der Mittelwert C avg</table>
		</figure>


		<figure type="table">

            <head>Tabelle </head>
 
            <label>1</label>

            <head>: Testinstanzen und die verwendete Laufzeit<lb/> </head>
<lb/> 
            <table>Instanz Knoten Cluster Laufzeit[s]<lb/> kroa150<lb/> 150<lb/> 30<lb/> 150<lb/> rat195<lb/> 195<lb/> 39<lb/> 150<lb/> d198<lb/> 198<lb/> 40<lb/> 150<lb/> krob200<lb/> 200<lb/> 40<lb/> 150<lb/> ts225<lb/> 225<lb/> 45<lb/> 200<lb/> pr226<lb/> 226<lb/> 46<lb/> 200<lb/> gil262<lb/> 262<lb/> 53<lb/> 300<lb/> pr264<lb/> 264<lb/> 54<lb/> 300<lb/> pr299<lb/> 299<lb/> 60<lb/> 300<lb/> lin318<lb/> 318<lb/> 64<lb/> 400<lb/> rd400<lb/> 400<lb/> 80<lb/> 450<lb/> fl417<lb/> 417<lb/> 84<lb/> 450<lb/> pr439<lb/> 439<lb/> 88<lb/> 600<lb/> pcb442<lb/> 442<lb/> 89<lb/> 600</table>
		</figure>


		<figure type="table">

            <table>0<lb/> 26<lb/> 11.081<lb/> 61<lb/> 857 10.721 23.394<lb/> rat195<lb/> 0<lb/> 0<lb/> 1<lb/> 5.982<lb/> 32<lb/> 635 3.376 14.438<lb/> d198<lb/> 0<lb/> 0<lb/> 3<lb/> 5.103<lb/> 410 5.500 11.913 14.468<lb/> krob200 0<lb/> 0<lb/> 1<lb/> 5.376<lb/> 19<lb/> 243 1.193 7.590<lb/> ts225<lb/> 0<lb/> 0<lb/> 0<lb/> 3.362<lb/> 0<lb/> 1<lb/> 99<lb/> 5.646<lb/> pr226<lb/> 0<lb/> 0<lb/> 3<lb/> 3.301<lb/> 721 6.687 12.744 15.731<lb/> gil262<lb/> 0<lb/> 0<lb/> 5<lb/> 6.937<lb/> 13<lb/> 295 3.067 9.529<lb/> pr264<lb/> 0<lb/> 0<lb/> 10<lb/> 5.473<lb/> 525 5.764 14.587 13.011<lb/> pr299<lb/> 0<lb/> 0<lb/> 1<lb/> 3.318<lb/> 45<lb/> 544 2.541 9.306<lb/> lin318<lb/> 0<lb/> 0<lb/> 6<lb/> 5.187<lb/> 332 3.119 12.809 16.113<lb/> rd400<lb/> 0<lb/> 0<lb/> 1<lb/> 3.475<lb/> 55<lb/> 637 4.898 9.744<lb/> fl417<lb/> 0<lb/> 0<lb/> 0<lb/> 1.835 2.741 14.811 10.400 7.802<lb/> pr439<lb/> 0<lb/> 0<lb/> 1<lb/> 3.141<lb/> 457 2.238 4.790 7.617<lb/> pcb442<lb/> 0<lb/> 0<lb/> 1<lb/> 3.349<lb/> 12<lb/> 360 2.510 6.367</table>
		</figure>


		<figure type="table">

            <table>kroa150 9.822,0 60.747 9.822,0 52.511 9.819,9 29.509 9.819,6<lb/> 26.609<lb/> (21,4)<lb/> (12,7)<lb/> (17,7)<lb/> (17,8)<lb/> rat195 754,4 33.232 752,7 28.739 752,9<lb/> 17.602<lb/> 753,9<lb/> 14.481<lb/> (4,7)<lb/> (3,1)<lb/> (3,5)<lb/> (4,1)<lb/> d198 7.054,6 29.272 7.051,5 23,219 7.052,4 14.513 7.053,3<lb/> 12.707<lb/> (7,6)<lb/> (5,3)<lb/> (4,5)<lb/> (3,5)<lb/> krob200 11.248,831.790 11.246,1 22.863 11.245,3 16.887 11.260,6 14.727<lb/> (8,7)<lb/> (6,3)<lb/> (5,1)<lb/> (11,0)<lb/> ts225 62.306,332.698 62.275,4 26.467 62.286,5 20.472 62.292,1 18.346<lb/> (59,3)<lb/> (17,7)<lb/> (23,9)<lb/> (46,5)<lb/> pr226 55.515,031.541 55.515,0 25.289 55.515,0 12.098 55.515,0 10.576<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 944,5 37.349 942,7 22.549 944,1<lb/> 19.123<lb/> 942,8<lb/> 15.878<lb/> (3,8)<lb/> (2,2)<lb/> (4,3)<lb/> (2,7)<lb/> pr264 21.895,133.368 21.891,1 21.467 21.890,1 16.071 21.890,6 11.679<lb/> (11,7)<lb/> (6,6)<lb/> (6,0)<lb/> (8,4)<lb/> pr299 20.354,326.404 20.339,7 15.985 20.346,2 13.081 20.341,0 11.389<lb/> (41,0)<lb/> (21,6)<lb/> (30,0)<lb/> (25,4)<lb/> lin318 18.540,527.309 18.535,1 21.289 18.532,4 13.220 18.528,0 10.738<lb/> (25,4)<lb/> (21,2)<lb/> (16,3)<lb/> (15,1)<lb/> rd400 5.950,6 21.185 5.945,4 14.815 5.947,6 9.260<lb/> 5.945,6<lb/> 8.261<lb/> (13,9)<lb/> (10,8)<lb/> (13,4)<lb/> (11,5)<lb/> fl417 7.982,0 22.146 7.982,0 15.208 7.982,0 6.324<lb/> 7.982,0<lb/> 5.457<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.873,917.653 51.828,2 7.855 51.827,0 10.339 51.826,3<lb/> 8.651<lb/> (54,5)<lb/> (35,5)<lb/> (35,7)<lb/> (26,7)<lb/> pcb442 19.667,218.106 19.657,4 7.576 19.648,9 10.707 19.654,5<lb/> 8.707<lb/> (38,0)<lb/> (40,3)<lb/> (27,3)<lb/> (34,3)<lb/> 3.2.3 Nearest Neighbours<lb/> Als nächstes wurde versucht herauszufinden, wie sich der Nearest-Neighbours-Ansatz,<lb/> der in Kapitel 2.2.2 erläutert wurde, auf den Evolutionären Algorithmus auswirkt. Bei<lb/> diesen Tests wurde der EA ohne Archiv verwendet. Dabei wurde der EA einmal mit und<lb/> einmal ohne dem Nearest-Neighbours-Ansatz verwendet und miteinander verglichen. Bei diesem Test wurde der Parameter num_nearest_neighbour, der angibt, wie viele<lb/> Nachbarn in der Nearest-Neighbour-List eines Clusters enthalten sind, auf 5 gesetzt.<lb/> D.h. es werden für jeden Cluster die 5 nächsten Nachbarn bevorzugt. In Tabelle 4 sind<lb/> die Ergebnisse dieses Tests dargestellt. Hier ist zu sehen, dass der EA mit dem Nearest-<lb/>Neighbours-Ansatz für alle Instanzen eine Verbesserung liefert. Für die nachfolgenden<lb/> Tests wurde daher der Nearest-Neighbours-Ansatz auch verwendet.<lb/> Tabelle 4: Vergleich von &quot;normalen&quot; EA mit einem EA mit Nearest Neighbours<lb/> EA<lb/> EA+NN<lb/> Instanz<lb/> C avg (T )<lb/> Gen<lb/> C avg (T )<lb/> Gen<lb/> kroa150<lb/> 9.831,8 302.576 9.831,5 303.589<lb/> (30,9)<lb/> (30,3)<lb/> rat195<lb/> 761,1<lb/> 199.953<lb/> 760,3<lb/> 199.391<lb/> (6,3)<lb/> (5,8)<lb/> d198<lb/> 7.068,7 183.405 7.057,3 180.270<lb/> (10,9)<lb/> (14,1)<lb/> krob200 11.291,4 185.572 11.277,6 185.052<lb/> (45,3)<lb/> (36,2)<lb/> ts225<lb/> 62.565,7 213.360 62.456,7 213.926<lb/> (131,1)<lb/> (152,7)<lb/> pr226<lb/> 55.515,0 199.954 55.515,0 200.307<lb/> (0,0)<lb/> (0,0)<lb/> gil262<lb/> 949,8<lb/> 244.354<lb/> 946,8<lb/> 243.635<lb/> (5,6)<lb/> (5,1)<lb/> pr264<lb/> 21.950,9 229.337 21.936,9 227.352<lb/> (29,9)<lb/> (32,2)<lb/> pr299<lb/> 20.411,4 187.223 20.369,1 185.952<lb/> (55,6)<lb/> (59,7)<lb/> lin318<lb/> 18.553,7 223.100 18.550,4 221.801<lb/> (33,9)<lb/> (30,3)<lb/> rd400<lb/> 5.993,6 166.799 5.978,6 165.978<lb/> (33,0)<lb/> (32,6)<lb/> fl417<lb/> 7.996,0 148.236 7.989,5 147.630<lb/> (6,9)<lb/> (8,2)<lb/> pr439<lb/> 52.045,4 178.455 52.016,5 177.110<lb/> (124,9)<lb/> (109,2)<lb/> pcb442 19.830,7 180.509 19.762,4 181.069<lb/> (113,7)<lb/> (113,6)<lb/> 35<lb/> 3.2. Tests mit fixer Laufzeit<lb/> Tabelle 5: Vergleich der verschiedenen Bounding-Varianten im Pop-Archiv<lb/> Trie<lb/> Trie+insert-Bound Trie+convert-Bound Trie+ins&amp;conv-Bound<lb/> Instanz C avg (T ) |Gen| C avg (T ) |Gen| C avg (T ) |Gen| C avg (T )<lb/> |Gen|<lb/> kroa150 9.815,0 62.747 9.815,0 44.525 9.815,0 32.376 9.815,0<lb/> 24.844<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> rat195 752,5 36.732 751,5 25.765 751,9<lb/> 22.772<lb/> 752,2<lb/> 16.854<lb/> (3,0)<lb/> (2,0)<lb/> (2,5)<lb/> (2,7)<lb/> d198 7.046,1 30.787 7.044,0 20.328 7044,0 14.011 7.044,3<lb/> 10.249<lb/> (3,9)<lb/> (0,0)<lb/> (0,0)<lb/> (1,6)<lb/> krob200 11.245,3 34.399 11.244,0 24.306 11.244,0 21.614 11.246,0 17.198<lb/> (5,1)<lb/> (0,0)<lb/> (0,0)<lb/> (6,1)<lb/> ts225 62.268,7 38.580 62.268,2 28.141 62.268,5 29.270 62.268,5 22.654<lb/> (0,5)<lb/> (0,4)<lb/> (0,5)<lb/> (0,5)<lb/> pr226 55.515,033.056 55.515,0 19.713 55.515,0 17.736 55.515,0 10.571<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 942,4 38.873 942,0 25.842 942,3<lb/> 24.078<lb/> 942,7<lb/> 18.201<lb/> (2,0)<lb/> (0,0)<lb/> (2,0)<lb/> (2,7)<lb/> pr264 21.886,0 36.538 21.886,0 23.104 21.886,0 22.734 21.886,0 13.226<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr299 20.318,6 28.971 20.316,1 18.548 20.316,0 20.506 20.320,6 13.950<lb/> (14,2)<lb/> (0,5)<lb/> (0,0)<lb/> (17,5)<lb/> lin318 18.525,5 34.659 18.523,9 17.283 18.523,0 22.782 18.522,2 11.108<lb/> (15,0)<lb/> (9,4)<lb/> (14,3)<lb/> (10,5)<lb/> rd400 5.945,2 25.867 5.943,2 14.627 5.942,5 19.263 5.942,7<lb/> 10.666<lb/> (16,5)<lb/> (7,9)<lb/> (6,9)<lb/> (7,2)<lb/> fl417 7.982,0 23.200 7.982,0 8.683 7.982,0 13.515 7.982,0<lb/> 2.578<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.796,5 24.933 51.794,0 14.215 51.793,5 20.692 51.791,6<lb/> 9.734<lb/> (29,7)<lb/> (16,6)<lb/> (10,8)<lb/> (2,7)<lb/> pcb442 19.630,2 26.755 19634,4 15.859 19.627,7 22.892 19.627,4 13.407<lb/> (23,6)<lb/> (20,2)<lb/> (15,7)<lb/> (15,6)<lb/> 3.2.4 Pop-Archiv<lb/> In diesem Kapitel wurde der Vergleich der verschiedenen Bounding-Strategien auch für<lb/> das Pop-Archiv durchgeführt. In Kapitel 3.2.1 wurde in dem Test herausgefunden, dass<lb/> Cuts in allen Ebenen des Tries vorkommen können. Deshalb wurde für den Vergleich<lb/> der Bounding-Strategien der Parameter skip_bound hier nicht verwendet, d.h. die Bound wurde in jeder Ebene berechnet. Für den Parameter branch_and_bound_prob<lb/> wurden für das Pop-Archiv, genau wie im Kapitel 3.2.2 für das Gosh-Archiv, Tests mit<lb/> unterschiedlichen Werten für diesen Parameter gemacht. Mit dem Resultat, dass auch<lb/> hier der Wert 0, 05 die besseren Ergebnisse liefert.</table>
		</figure>


		<figure type="table">

            <table>522,916.954 18.515,9 8.576 18.517,7 8.670 18.519,5<lb/> 5.218<lb/> (9,2)<lb/> (12,4)<lb/> (8,7)<lb/> (8,3)<lb/> rd400 5.940,3 14.236 5.937,7 6.692 5.938,9 8.545<lb/> 5.939,9<lb/> 5.184<lb/> (6,4)<lb/> (5,8)<lb/> (7,6)<lb/> (5,6)<lb/> fl417 7.982,0 1.486 7.982,0 875<lb/> 7.982,0<lb/> 585<lb/> 7.982,0<lb/> 418<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.791,012.837 51.792,2 6.101 51.791,0 9.331 51.791,0<lb/> 4.716<lb/> (0,0)<lb/> (6,4)<lb/> (0,0)<lb/> (0,0)<lb/> pcb442 19.625,817.457 19.623,6 8.198 19.620,5 10.872 19.622,8<lb/> 6.961<lb/> (19,1)<lb/> (17,4)<lb/> (18,7)<lb/> (18,3) In den bisherigen Tests ist zu sehen, dass durch die Verwendung der Bounding-Strategie<lb/> die Anzahl der erzeugten Generationen geringer sind. Dadurch ist ein Vergleich des<lb/> Speicherverbrauchs der beiden Varianten nicht möglich, da bei dem Archiv ohne Bound-<lb/>ing mehr Lösungen in das Archiv eingefügt werden als beim Archiv mit Bounding.<lb/> Um jetzt den Speicherverbrauch der unterschiedlichen Varianten miteinander zu ver-<lb/>gleichen, wird als Abbruchbedingung für den EA eine fixe Anzahl von Generationen<lb/> genommen. So werden bei allen Varianten gleich viele Generationen erzeugt.<lb/> Für diese Tests wurde die Abbruchbedingung des EAs auf 10.000 Generationen gesetzt.<lb/> In den Tabellen 7 und 8 sind die Ergebnisse für diese Tests zu sehen. In der Tabelle<lb/> 7 wurde das Gosh-Archiv untersucht, während in Tabelle 8 die Ergebnisse für das<lb/> Pop-Archiv zu sehen sind. Es wurden jeweils das &quot;normale&quot; Archiv ohne Bounding-<lb/>Strategie, das mit Bounding-Strategie in der Einfüge-Methode und das mit Bounding-<lb/>Strategie in der Konvertierungs-Methode miteinander verglichen. Die Spalte C avg ent-<lb/>spricht dabei wieder dem Durchschnitt der Lösungswerte über alle Runs, unter diesem<lb/> Wert steht in Klammern die Standardabweichung, Zeit entspricht der durchschnittlich<lb/> benötigten Zeit und M em den benötigten Speicher für das Archiv.<lb/> In diesen Ergebnissen ist zu sehen, dass die Varianten mit Bound immer mehr Spei-<lb/>cher benötigen als die ohne Bound. Das kommt zunächst überraschend, da man zuerst<lb/> annehmen würde, dass durch die Bounding-Strategie auch weniger Speicher verbraucht<lb/> würde. Der Grund für den erhöhten Speicherverbrauch bei der Einfüge-Methode ist<lb/> in Abb. 8 zu sehen. In diesem Beispiel wird zunächst versucht, im Gosh-Archiv die<lb/> Lösung &lt;321112&gt; (in der Grafik rot dargestellt) einzufügen. In Knoten V 5 wird eine<lb/> Bound festgestellt, die schlechter ist als die beste bisher gefundene Lösung, und somit<lb/> der Pointer 1 als complete markiert. Danach wird die Einfügeoperation abgebrochen<lb/> und f alse zurück geben. Für den EA sieht es daher so aus, als wäre die Lösung im<lb/> Archiv schon enthalten. Im nächsten Schritt wird mit der Konvertierungsmethode eine<lb/> neue Lösung &lt;341112&gt; erzeugt. Diese wird nun erfolgreich in das Archiv eingefügt.<lb/> Würde die Bounding-Strategie nicht verwendet werden, wäre die Lösung &lt;321112&gt;<lb/> beim ersten Mal eingefügt worden. Da die Bounding-Strategie verwendet wurde, ist nun<lb/> die Lösung &lt;321112&gt; bis zum Knoten V 5 und die Lösung &lt;341112&gt; ganz eingefügt<lb/> worden. D.h. beim Erzeugen einer neuen Lösung für die neue Generation wurden die<lb/> drei Knoten V 3, V 4 und V 5 des ersten Einfügeversuchs zusätzlich eingefügt. Deshalb<lb/> kommt es bei der Verwendung der Bounding-Strategie zu einem höheren Speicherver-<lb/>brauch.<lb/> </table>
<lb/> 
            <figDesc>Um zu belegen, dass das der Grund für den erhöhten Speicherverbrauch ist, wurden<lb/> weitere Tests durchgeführt. Bei diesen Tests wurden Lösungen, bei denen eine Bound gefunden wurde, die schlechter ist als die beste bisher gefundene Lösung, trotzdem in<lb/> der neuen Generation akzeptiert. D.h. wenn beim Einfügen einer Lösung eine schlechte<lb/> Bound gefunden wird, wird der jeweilige Pointer als complete markiert und dann true<lb/> zurück gegeben. Das hat zur Folge, dass der EA die Lösung als neu akzeptiert.<lb/> Die Ergebnisse dieser Variante werden in Tabelle 9 gezeigt. Hier ist zu sehen, dass<lb/> für die meisten Instanzen bei dieser Variante weniger Speicher für das Archiv gebraucht<lb/> wurde.</figDesc>
		</figure>


		<figure type="table">

            <table>9.828,8 23<lb/> 6,7<lb/> 9.819,3 36<lb/> 8,0<lb/> 9.823,1 33<lb/> 6,6<lb/> (27,5)<lb/> (11,4)<lb/> (17,8)<lb/> rat195 755,9<lb/> 39<lb/> 10,7<lb/> 758,3<lb/> 75<lb/> 12,5<lb/> 757,6<lb/> 52<lb/> 11,4<lb/> (5,2)<lb/> (5,6)<lb/> (5,0)<lb/> d198 7.061,7 49<lb/> 8,2<lb/> 7.062,9 82<lb/> 9,7<lb/> 7.063,3 76<lb/> 8,4<lb/> (9,5)<lb/> (9,0)<lb/> (8,4)<lb/> krob200 11.269,1 42<lb/> 10,0<lb/> 11.273,9 68<lb/> 11,6<lb/> 11.279,9 58<lb/> 10,3<lb/> (25,2)<lb/> (42,0)<lb/> (48,3)<lb/> ts225 62.422,1 49<lb/> 17,3<lb/> 62.406,5 73<lb/> 19,0<lb/> 62.404,7 65<lb/> 16,6<lb/> (106,2)<lb/> (92,5)<lb/> (101,6)<lb/> pr226 55.515,0 64<lb/> 6,8<lb/> 55.515,0 126<lb/> 7,7<lb/> 55.515,0 128<lb/> 6,7<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 948,9<lb/> 74<lb/> 17,9<lb/> 947,5 123<lb/> 21,3<lb/> 948,4 95,6<lb/> 18,2<lb/> (5,1)<lb/> (4,7)<lb/> (4,3)<lb/> pr264 21.913,2 80<lb/> 15,1<lb/> 21.905,0 139<lb/> 17,8<lb/> 21.914,9 118<lb/> 15,3<lb/> (31,4)<lb/> (18,2)<lb/> (26,1)<lb/> pr299 20.402,5 101<lb/> 18,8<lb/> 20.398,5 174<lb/> 22,1<lb/> 20.370,9 144<lb/> 19,1<lb/> (55,4)<lb/> (45,7)<lb/> (39,3)<lb/> lin318 18.548,9 113<lb/> 17,8<lb/> 18.545,6 217<lb/> 22,1<lb/> 18.556,1 183<lb/> 17,7<lb/> (26,6)<lb/> (22,1)<lb/> (27,5)<lb/> rd400 5.977,7 168<lb/> 25,8<lb/> 5.974,1 318<lb/> 31,9<lb/> 5.981,9 263<lb/> 25,7<lb/> (22,3)<lb/> (25,9)<lb/> (21,0)<lb/> fl417 7.982,0 204<lb/> 18,1<lb/> 7.982,0 499<lb/> 20,5<lb/> 7.982,0 478<lb/> 18,3<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.954,4 243<lb/> 28,9<lb/> 51.949,2 466<lb/> 34,3<lb/> 51.947,1 365<lb/> 62,8<lb/> (54,3)<lb/> (50,3)<lb/> (64,4)<lb/> pcb442 19.829,7 217<lb/> 34,4<lb/> 19.791,0 406<lb/> 41,1<lb/> 19.837,9 309<lb/> 34,5<lb/> (105,0)<lb/> (75,2)<lb/> (109,1)<lb/> 41<lb/> 3.3. Fixe Anzahl von Generationen<lb/> Tabelle 8: Vergleich von Pop-Trie mit 10000 Generationen<lb/> Trie<lb/> Trie+insert-Bound<lb/> Trie+convert-Bound<lb/> Instanz C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B] C avg (T ) Zeit [s]M em [M B]<lb/> kroa150 9.815,0 24<lb/> 28,9<lb/> 9.815,0 35<lb/> 42,3<lb/> 9.815,0 37<lb/> 32,8<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> rat195 751,6<lb/> 41<lb/> 55,4<lb/> 751,5<lb/> 64<lb/> 84,1<lb/> 752,1<lb/> 58<lb/> 59,5<lb/> (2,1)<lb/> (2,0)<lb/> (2,8)<lb/> d198 7.046,5 49<lb/> 49,0<lb/> 7.045,4 90<lb/> 95,9<lb/> 7.044,6 99<lb/> 54,1<lb/> (4,0)<lb/> (3,3)<lb/> (2,3)<lb/> krob200 11.246,1 44<lb/> 58,3<lb/> 11.246,3 66<lb/> 75,7<lb/> 11.244,7 55<lb/> 61,2<lb/> (6,2)<lb/> (6,4)<lb/> (3,7)<lb/> ts225 62.268,5 53<lb/> 84,7<lb/> 62.268,5 74<lb/> 96,9<lb/> 62.268,4 61<lb/> 85,3<lb/> (0,5)<lb/> (0,5)<lb/> (0,5)<lb/> pr226 55.515,0 61<lb/> 76,1<lb/> 55.515,0 140<lb/> 171,2<lb/> 55.515,0 100<lb/> 89,3<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> gil262 942,4<lb/> 78<lb/> 111,4<lb/> 942,5 128<lb/> 158,3<lb/> 942,4<lb/> 93<lb/> 115,8<lb/> (2,0)<lb/> (2,3)<lb/> (2,0)<lb/> pr264 21.886,0 83<lb/> 108,5<lb/> 21.886,0 169<lb/> 210,9<lb/> 21.886,0 106<lb/> 115,9<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr299 20.325,3 105<lb/> 133,6<lb/> 20.318,6 202<lb/> 225,2<lb/> 20.317,7 129<lb/> 137,4<lb/> (19,5)<lb/> (9,3)<lb/> (7,8)<lb/> lin318 18.521,4 116<lb/> 163,5<lb/> 18.519,5 298<lb/> 384,1<lb/> 18.524,2 152<lb/> 174,2<lb/> (13,2)<lb/> (14,2)<lb/> (12,8)<lb/> rd400 5.943,0 178<lb/> 264,7<lb/> 5.942,8 502<lb/> 600,1<lb/> 5.944,7 212<lb/> 276,9<lb/> (9,7)<lb/> (7,1)<lb/> (7,8)<lb/> fl417 7.982,0 196<lb/> 265,0<lb/> 7.982,0 1.041<lb/> 845,7<lb/> 7.982,0 326<lb/> 302,5<lb/> (0,0)<lb/> (0,0)<lb/> (0,0)<lb/> pr439 51.792,3 248<lb/> 309,3<lb/> 51.793,0 687<lb/> 679,3<lb/> 51.791,1 267<lb/> 315,3<lb/> (6,7)<lb/> (8,0)<lb/> (0,3)<lb/> pcb442 19.628,9 229<lb/> 360,0<lb/> 19.628,1 527<lb/> 615,6<lb/> 19.633,6 244<lb/> 367,4<lb/> (20,5)<lb/> (19,1)<lb/> (21,4)<lb/> 42<lb/> 3.4. State of the Art<lb/> Tabelle 9: Vergleich von Pop-Tries mit 10000 Generationen ohne return<lb/> Trie<lb/> Trie+insert-Bound<lb/> Instanz<lb/> C avg (T ) Zeit [s] M em [M B] C avg (T ) Zeit [s] M em [M B]<lb/> kroa150<lb/> 9.815,0<lb/> 24<lb/> 28,9<lb/> 9.815,0<lb/> 36<lb/> 29,2<lb/> (0,0)<lb/> (0,0)<lb/> rat195<lb/> 751,6<lb/> 41<lb/> 55,4<lb/> 751,5<lb/> 61<lb/> 54,6<lb/> (2,1)<lb/> (2,0)<lb/> d198<lb/> 7.046,5<lb/> 49<lb/> 49,0<lb/> 7.045,6<lb/> 89<lb/> 44,4<lb/> (4,0)<lb/> (3,4)<lb/> krob200 11.246,1<lb/> 44<lb/> 58,3<lb/> 11.244,7<lb/> 62<lb/> 58,3<lb/> (6,2)<lb/> (3,7)<lb/> ts225<lb/> 62.268,5<lb/> 53<lb/> 84,7<lb/> 62.268,4<lb/> 71,9<lb/> 82,8<lb/> (0,5)<lb/> (0,5)<lb/> pr226<lb/> 55.515,0<lb/> 61<lb/> 76,1<lb/> 55.515,0<lb/> 106<lb/> 75,8<lb/> (0,0)<lb/> (0,0)<lb/> gil262<lb/> 942,4<lb/> 78<lb/> 111,4<lb/> 942,3<lb/> 111<lb/> 111,9<lb/> (2,0)<lb/> (2,0)<lb/> pr264<lb/> 21.886,0<lb/> 83<lb/> 108,5<lb/> 21.886,0<lb/> 121<lb/> 101,8<lb/> (0,0)<lb/> (0,0)<lb/> pr299<lb/> 20.325,3<lb/> 105<lb/> 133,6<lb/> 20.320,3<lb/> 158<lb/> 130,9<lb/> (19,5)<lb/> (13,0)<lb/> lin318<lb/> 18.521,4<lb/> 116<lb/> 163,5<lb/> 18.522,4<lb/> 183<lb/> 156,8<lb/> (13,2)<lb/> (11,2)<lb/> rd400<lb/> 5.943,0<lb/> 178<lb/> 264,7<lb/> 5.944,7<lb/> 292<lb/> 259,6<lb/> (9,7)<lb/> (7,7)<lb/> fl417<lb/> 7.982,0<lb/> 196<lb/> 265,0<lb/> 7.982,0<lb/> 384<lb/> 239,5<lb/> (0,0)<lb/> (0,0)<lb/> pr439<lb/> 51.792,3<lb/> 248<lb/> 309,3<lb/> 51.791,0 377,9<lb/> 299,2<lb/> (6,7)<lb/> (0,0)<lb/> pcb442 19.628,9<lb/> 229<lb/> 360,0<lb/> 19.630,5<lb/> 354<lb/> 355,2<lb/> (20,5)<lb/> (21,8)</table>
		</figure>



    </text>
</tei>

