<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 C:\Users\Angela\git\grobid\grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="de">
		<encodingDesc>
			<appInfo>
				<application version="0.4.5-dummy" ident="GROBID" when="2017-12-29T00:16+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>! FAKULTÄT FÜR !NFORMATIK</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract/>
		</profileDesc>
	</teiHeader>
	<text xml:lang="de">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Danksagung</head><p>Die vorliegende Arbeit durfte ich am Institut fü Computergraphik und Algorithmen der Technischen Universitä Wien erstellen und es freut mich diese nun fertig in Hä halten zu kö.</p><p>Ich mö mich fü die Geduld und Mithilfe von Seiten Gü Raidls bedanken und ebenso Matthias Prandtstetter großen Dank fü seine Betreuung aussprechen. In den vergangenen Monaten hat er einen besonders großen Beitrag zur Vervollstä- gung dieser Arbeit geleistet. Natü gilt meine Anerkennung auch allen anderen Personen, die von Seiten des Instituts ihren Anteil an der Entstehung dieser Arbeit hatten.</p><p>Es ist mir weiters ein Anliegen auch all jene zu erwä, die mich im Laufe des gesamten Studiums begleitet und unterstü haben. Dazu zä vor allem meine Studienkollegen Christian und Gerhard, sowie gleichermaßen auch meine Eltern, die mir zu jedem Zeitpunkt eine große Hilfe waren und Linda, der ich an dieser Stelle fü ihre Ausdauer und Motivation danken will.</p><p>iii iv Erklä zur Verfassung der Arbeit Hiermit erklä ich, Thomas Misar, wohnhaft in 1070 Wien, Seidengasse 3/108, dass ich diese Arbeit selbstä verfasst habe, dass ich die verwendeten Quellen und Hilfs- mittel vollstä angegeben habe und dass ich die Stellen der Arbeit (einschließlich Tabellen, Karten und Abbildungen), die anderen Werken oder dem Internet im Wort- laut oder dem Sinn nach entnommen sind, auf jeden Fall unter Angabe der Quelle als Entlehnung kenntlich gemacht habe. <ref type="bibr">Wien, 20.04.2009</ref> ( Währendü die definierten Nachbarschaftsstrukturen unterschiedliche potentielle Lö erzeugt werden, erfolgt deren Bewertung durch die Berechnung von konkreten Touren mittels eines fü diesen Zweck entwickelten Dynamischen Programms. Dabei werden spezielle Eigenschaften der zugrundeliegenden Lagerstruktur ausgenutzt, um so in po- lynomieller Zeit die bestmö Wegfü durch das Lager berechnen zu kö. Fü die Zuordnung von Arbeitern zu den auf diese Weise berechneten Touren wird schließlich eine zusä VNS verwendet, deren Aufgabe es ist, die notwendigen Touren derart zu verteilen, dass der letzte Artikel zum frü mö Zeitpunkt ausgefasst werden kann.</p><p>Die anhand des implementierten Programms durchgefü Tests zeigen, dass die erfolgte Tourenplanung wertvolle Ergebnisse liefert und die notwendige Rechenzeit niedrig gehalten werden kann. Getestet wurde mit Bezug auf eine Referenzlö, welche auf Basis eines aus der Literatur entnommenen Ansatzes erzeugt werden konn- te. Eine ausfü Auswertung der Testergebnisse zeigte, dass die Anwendung des hier vorgestellten Ansatzes im Echtbetrieb als sehr vielversprechend gilt und er- hebliche Einsparungen bezü der benö Arbeitszeit erreicht werden kö. Insgesamt betrachtet wird ein effizientes und zielfü Verfahren zur Lö des vorliegenden Problems vorgestellt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>vii viii</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abstract</head><p>Within this thesis a real-world problem related to a warehouse for spare parts is considered. Regarding several constraints typically stated by spare parts suppliers the time needed to collect articles should be minimized. Based on continuously arriving orders by customers predefined delivery times and capacity constraints have to be met. To accomplish this task efficient pickup tours need to be determined which is the main issue covered by this work which comes to an end with experimental results of a concrete implementation of the proposed approach.</p><p>The algorithm presented embeds a specifically developed dynamic program for com- puting optimal walks through the warehouse into a general variable neighborhood search (VNS) scheme. Several stages are used for first splitting up all orders, then creating tours out of the results and finally assigning them to available workers. The VNS uses a variant of the variable neighborhood descent (VND) as local improve- ment procedure. While the neighborhood structures defined are intended to produce candidate solutions, a dynamic program specially designed to compute optimal order picking tours is used to evaluate them. For this purpose properties specific to ware- houses are exploited such to compute optimal routes within polynomial time. The final assignment of workers to tours is realized by another VNS. The task is then to find an allocation such that the last article to be picked up will be collected as early as possible.</p><p>Evaluations of experimental results of a concrete implementation indicate that the presented approach provides valuable pickup plans and computation times can be kept low. Moreover the performed test runs have been compared to a reference so- lution which was computed based on an approach found in relevant literature. A detailed analysis of the obtained results showed that the application of the proposed approach to real-world instances is promising whereas the savings with respect to working time can be kept high. Overall an efficient as well as effective approach is introduced to solve this real-world problem.  Im Anschluss an die Beschreibung des Algorithmus kann man anhand der Testergeb- nisse sehen, dass die Effizienz des Programms einen durchwegs positiven Eindruck vermittelt. Große Probleminstanzen kö zwar sehr lange Laufzeiten im Bereich von mehreren Stunden benö, bis der Algorithmus keine weitere Verbesserung bringt, allerdings werden schon innerhalb der ersten Minuten gute Lö erzeugt und somit bleibt der Einsatz in der Praxis vielversprechend.</p><p>Zuerst werde ich nun eine detaillierte Problembeschreibung geben, die als Basis fü meine Untersuchungen gedient hat. Im Anschluss daran mö ich anhand von ver- wandten Arbeiten aus der Literatur einen¨Uberblicküber einen¨Uberblickü den Rahmen geben, in dem sich diese Arbeit bewegt. Ich werde im Weiteren beschreiben, aus welchen Teilen der letztlich verwendete Algorithmus aufgebaut ist und mit welchen Methoden der zuvor beschriebenen Arbeiten hierbei vorgegangen wird, wobei auch diese, wo sinnvoll und passend, im Detail behandelt werden. Im Zuge der Erlä zum algorithmi- schen Verlauf, werde ich auch auf einige spezielle Probleme eingehen, die in diesem Zusammenhang zu lö waren. Abschließend werden dann die Ergebnisse, die mit dem vorhandenen Programm erzielt werden konnten und aufgrund statistischer Aus- wertungen mehrerer Testlä zustande gekommen sind, die Arbeit abschließen. <ref type="bibr" target="#b3">2</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problembeschreibung</head><p>Die folgende Aufgabenstellung stammt in ihrer ursprü Form von der Firma Dataphone GmbH und wurde in Zusammenarbeit mit Mitarbeitern des Instituts fü Computergraphik und Algorithmen der Technischen Universitä Wien angepasst, um innerhalb eines gemeinsamen Projekts einen Lö dafü zu entwerfen.</p><p>Im Zuge der Reorganisation und Erweiterung des Lagers eines Ersatzteillieferanten soll eine automationstechnisch unterstü Lagerverwaltung eingefü und ausge- baut werden, die unter anderem die Mö bieten soll, einzelne Prozessablä im Lageralltag zu rationalisieren. Zu diesem Zweck wurden sä Artikel bezie- hungsweise jene Ladungsträ, auf denen sich die Artikel befinden, mit maschinen- lesbaren Kodierungen, konkret mit Barcodes, versehen und eine zentrale Lagerver- waltungssoftware eingefü. Auf Basis einer im Hintergrund eingerichteten Daten- bank erlaubt die grafische Oberflä der Software die Erfassung und Verwaltung von Stammdaten und Bestelldaten sowie den Zugriff auf den aktuellen Lagerstand.</p><p>In einer ersten Ausbaustufe soll vor allem die Zusammenstellung der einzelnen von Kunden in Auftrag gegebenen Bestellungen mö effizient realisiert werden, wo- bei folgende Schritte zu berü sind:</p><p>1. Ein Kunde gibt eine Ersatzteillieferung in Auftrag.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Fü jeden Auftrag fasst ein Lagerarbeiter die erforderliche Anzahl der bestellten</head><p>Artikel aus dem Lager aus und bringt sie in eine so genannte Verdichtungszone.</p><p>3. Ein dieser Verdichtungszone zugeteilter Mitarbeiter packt alle zu den jeweili- gen Bestellungen gehö Einzelteile in entsprechend dimensionierte Kisten, versieht diese mit Adresstickets und leitet sie an den Lieferanten (Paketdienst, Post, etc.) weiter.</p><p>Wä der erste und der dritte Punkt dieser Abarbeitungsreihenfolge derzeit schon verlä und ohne grö Verzö ablaufen, stellt der zweite Punkt den Flaschenhals in der Zusammenstellung der Aufträ dar, da hierbei die Mitarbeiter große Strecken im Lager zurü mü, um alle Einzelteile einzusammeln. Da im Normalfall bis zu sechs Mitarbeiter gleichzeitig an bis zu 1000 tä Aufträ bestehend aus je fü unterschiedlichen Artikeln arbeiten, gibt es durch geschickte Aufteilung der Aufträ ein großes Einsparungspotential, sofern eine geschickte Ein- teilung von Artikeln zu Touren vorgenommen wird. Folgender neu gestalteter Ablauf soll daher realisiert werden:</p><p>1. Mehrere Kunden geben (unabhä voneinander) jeweils eine Ersatzteilliefe- rung in Auftrag.</p><p>2. Alle derzeit im Lager tä Mitarbeiter bekommen jeweils eine Liste von Artikeln, die sie entlang einer vorberechneten Tour im Lager auf Kommissio- nierungswagen laden sollen. Diese Artikel kö im Allgemeinen auch zu un- terschiedlichen Aufträ gehö.</p><p>3. Nach Abarbeitung dieser Liste stellt jeder Mitarbeiter den von ihm bedienten Kommissionierungswagen in der Verdichtungszone ab und entnimmt dort einen weiteren, allerdings leeren Kommissionierungswagen, um sich auf eine neue Tour zum Ausfassen weiterer Artikel zu machen. Gegenstand dieser Arbeit ist nun die Entwicklung eines Lö, mit dessen Hilfe es mö wird, die Aufteilung der Bestellungen auf unterschiedliche Mitarbei- ter derart zu optimieren, dass die Touren der Kommissionierer mö kurz wer- den, wodurch gleichzeitig der zeitliche Abstand zweier Entnahmen einzelner Artikel aus dem Lager minimiert wird. Ausschlaggebend hierfü ist, dass durch diese Auf- teilung der Bestellungen auf mehrere gleichzeitig im Lager arbeitende Personen bei entsprechender Optimierung große Einsparungen erreicht werden kö, da fü die Mitarbeiter besser organisierte Touren mit kü Wegen mö sind. Weiters soll erreicht werden, dass die jeweils zu einer gemeinsamen Bestellung gehö Artikel ungefä zeitgleich in der Verdichtungszone bereitgestellt und im Weiteren verpackt werden, um mehrere Aufträ ohne den Einsatz grö Zwischenlager gleichzeitig bearbeiten zu kö.</p><p>Neben dieser prinzipiellen Aufgabenstellung mü jedoch noch mehrere Nebenbe- dingungen berü werden, die einen entscheidenden Einfluss auf die tatsä- che Realisierung der einzelnen Kommissionierungstouren haben:</p><formula xml:id="formula_0">4 Verdichtungszone W W W W W W W W VZ 1 W W W W W W W W W W W W W W W W VZ 2 Verpackung &amp; Versand W W W W W W W W W W W W W W W W VZ 3 W W W W W W W W W Stellplatz fü Kommissionierungswagen</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Abbildung 2.1: Schematische Darstellung der Verdichtungszone</head><p>• Die Kommissionierungswagen kö einerseits nur bis zu einer gewissen Ka- pazitä beladen werden und andererseits ist es aufgrund ihrer Bauweise nur vorgesehen, dass sie sich in eine Richtung bewegen. Wegen des schmalen Gang- systems ist ein Umkehren innerhalb eines Ganges nicht ohne Weiteres mö.</p><p>• Dië Uberkreuzung zweier Kommissionierungstouren innerhalb eines Regalgan- ges sollte mö vermieden werden, da aufgrund der Platzbeschrä ein¨Uberholen oder aneinander Vorbeifahren nicht mö ist.</p><p>• Manche Artikel kö an mehreren Positionen im Lager verfü sein. Ab- hä von der bestellten Menge mü oder kö dann unter Umstä auch mehrere solcher Lagerplä fü einen Artikel angefahren werden.</p><p>• Einen weiteren Aspekt birgt die Tatsache, dass nicht alle an einem Tag zu bearbeitenden Bestellungen zu Arbeitsbeginn bereits bekannt sind, da noch im Laufe des Tages weitere Bestellungen eintreffen kö. Dies entspricht sogar eher dem Normalfall, wodurch Anzahl und Struktur der zu bearbeitenden Aufträ im Laufe des Tages stark variieren. Ein Lö soll das insofern berü, als die Berechnungen jederzeit mit angepassten Eingabewerten wieder gestartet werden kö sollen. Das heißt, es wird immer mit den aktuell offenen Bestellungen neu gerechnet.</p><p>• Die Bearbeitung von Bestellungen sollte nach Mö in der Reihenfolge ihres Eintreffens geschehen, um die Lieferzeiten mö sicher einhalten zu kö.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head><p>• Die zuvor beschriebene Einteilung der Verdichtungszone in drei Zonen muss derart berü werden, dass von den Kommissionierern ausnahmslos alle zu einer Bestellung gehö Artikel in derselben dieser drei Zonen abgeliefert werden.</p><p>Durch mobile Datenerfassungsgerä soll der Optimierungsprozess unterstü wer- den, da der Einsatz dieser Gerä es ermö, die Entnahme eines Artikels be- ziehungsweise Abgabe eines Kommissionierungswagens in der Verdichtungszone in Echtzeit nachzuvollziehen. Dieses neue Lagerverwaltungssystem soll das derzeitige Verfahren ablö, bei dem alle Entscheidungen durch Mitarbeiter getroffen werden.</p><p>Unter Berü dieser Einschrä gilt es nun vorrangig die Berechnung von kü Touren fü die Mitarbeiter zu behandeln.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mö Erweiterungen</head><p>Die folgende Auflistung erö mö Erweiterungen der gegebenen Problem- beschreibung, wobei deren Umsetzung aufgrund von massivem Mehraufwand nicht erfolgte. ¨ Uberdies beeinflussen diese Aspekte den Kern der Arbeit nicht, wodurch die zentralen Ergebnisse des vorgestellten Verfahrens ihre Aussagekraft behalten.</p><p>Folgende Punkte sind als zusä Funktionalitä und Optionen denkbar:</p><p>• Die im Lager verfü Kommissionierungswagen haben durchaus unter- schiedliche bauartliche Voraussetzungen, was sich auf damit verbundene Eigen- schaften, wie Geschwindigkeit, Ladeflä oder Manövrierfä, auswirkt. Ein entwickelter Lö dafü sollte dann genü Flexibilitä aufwei- sen, um damit umgehen zu kö. Die Palette an Transportmitteln reicht dabei von " einkaufswagenä" Fahrzeugen bis hin zu Gabelstaplern.</p><p>• Die eingeschrä Bewegungsfreiheit aufgrund der sehr schmalen Gä im Lager verhindert es, dass zwei Kommissionierungswagen aneinander vorbeifah- ren kö. Um Kollisionen auszuschließen, wä es denkbar einen Algorithmus zu entwerfen, der entsprechende Zustä verbietet.</p><p>• Ein weiterer Punkt in Zusammenhang mit den im Lager verwendeten Fahrzeu- gen bezieht sich auf die Sicherheitsbestimmungen in Bezug auf Gabelstapler. Diese schreiben es prinzipiell vor, dass sich in einem Gang kein anderer Mit- arbeiter gleichzeitig mit einem Gabelstapler aufhalten darf. Die Sperrung von solchen Gä muss dann natü berü werden.</p><p>• Es kann der Fall auftreten, dass der Lagerleiter befindet, einen Lagerplatz mit einem anderen Artikel belegen zu wollen. In einem solchen Fall muss die Mö gegeben sein, dass der anderweitig benö Lagerplatz mö schnell (gleichzeitig aber kosteneffizient) leer gerä wird.</p><p>• Weiters liegt durch das stä Eintreffen von Bestellungen im Laufe eines Ar- beitstages der Anspruch an eine Online-Optimierungsaufgabe nahe. Das heißt, dass aktuell eintreffende Bestellungen jederzeit in den Optimierungsprozess aufgenommen werden kö mü. Im Unterschied zu einem kompletten Neustart der Berechnungen mü in diesem Fall die bereits getä Opti- mierungen in den weiteren Verlauf des Programms einfließen.</p><p>• Außerdem kann es vorkommen, dass wä der Zusammenstellung der einzel- nen Aufträ unvorhersehbare Vorkommnisse auftreten, auf die entsprechend reagiert werden muss. Artikel kö beispielsweise fehlerhaft, kaputt oder gar nicht vorhanden sein. In einem solchen Fall muss der entsprechende Artikel von einer anderen Position im Lager entnommen werden oder mö sogar neu eingelagert werden. Wenn ein Lagerarbeiter mehr Zeit benö als angenommen, verzö sich natü auch die Kommissionierung und entspre- chendë Anderungen mü berü werden </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Capacitated Vehicle Routing Problem</head><p>Eine Variante des VRP ist das Capacitated Vehicle Routing Problem (CVRP) <ref type="bibr" target="#b18">[17]</ref>, welches die Kapazitä der verwendeten Fahrzeuge einschrä. Das in <ref type="bibr" target="#b18">[17]</ref> beschrie- bene CVRP verlangt die Auslieferung eines einzigen Gutes an n Kunden ausgehend von einem Depot {0} unter Verwendung von k unabhä Transportmitteln mit jeweils identischer Kapazitä C, wobei jedem Kunden i ∈ N = {1, . . . , n} die Menge d i zugestellt wird. Aus kombinatorischer Sicht handelt es sich bei der Lö um eine Aufteilung {R 1 , . . . , R k } von N in k Routen, wobei jede dieser Routen</p><formula xml:id="formula_1">j∈R i d j ≤ C, 1 ≤ i ≤ k erfü muss.</formula><p>Zum klassischen, bereits N P-schweren VRP kommen also noch zusä Ein- schrä hinzu, welche zu berü sind. Das Problem wird dadurch al- lerdings nicht leichter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Vehicle Routing Problem</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Split Delivery Vehicle Routing Problem</head><p>Das Split Delivery Vehicle Routing Problem (SDVRP) <ref type="bibr" target="#b3">[2]</ref> beschreibt jene Form des VRP, bei der ein Kunde mehrmals angefahren werden darf oder sogar muss. Wieder sind mehrere Lieferanten im Einsatz und jedes Transportmittel hat die gleiche Ka- pazitä. Nun kann es allerdings vorkommen, dass die benö Menge eines Kunden die Kapazitä eines einzelnen Transportmittelsübersteigt Transportmittelsü oder aber auch einfach aus Effizienzgrü zwei Lieferanten einen Kunden mit Teillieferungen beliefern.</p><p>Wie bereits bei Dror und Trudeau in <ref type="bibr" target="#b8">[7]</ref> und <ref type="bibr" target="#b9">[8]</ref> gezeigt, kö durch die Aufteilung von Lieferungen beträ Einsparungen erzielt werden, sowie auch die Anzahl an Lieferanten reduziert werden. Dennoch bleibt das Problem an sich N P-schwer.</p><p>Die meisten Lösungsansä gehen von der Annahme aus, dass die so genannte Drei- ecksungleichung erfü ist. Geht man von der Kostenberechnung auf Basis von Weg- strecken aus, so bedeutet dies, dass der direkte Weg zwischen zwei Knoten immer der kostengü ist. Formal lä sich das ganz leicht durch</p><formula xml:id="formula_2">c ij + c jk ≥ c ik , mit i, j, k ∈ {1, . . . , n}</formula><p>ausdrü, wobei n die Anzahl an Kunden reprä und c ij die Kosten fü den Weg von Kunde i zu Kunde j angibt. Es wird dabei angenommen, dass c ij = c ji gilt.</p><p>Ein interessanter Aspekt der zuvor erwä Arbeiten <ref type="bibr" target="#b8">[7]</ref> und <ref type="bibr" target="#b9">[8]</ref> ist die Erkenntnis, dass es bei geltender Dreiecksungleichung eine optimale Lö gibt, bei der je zwei Routen nie mehr als zwei gemeinsame Zielorte mit Teillieferungen anfahren.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Vehicle Routing Problem with Time Windows</head><p>Eine weitere Variante des VRP behandelt jene Problemstellung, bei der die Kunden innerhalb eines definierten Zeitfensters beliefert werden mü. Bei diesem Problem, dem Vehicle Routing Problem with Time Windows (VRPTW) <ref type="bibr" target="#b20">[19]</ref>, kann sich die Reihenfolge der zu beliefernden Kunden daher nicht ausschließlich aus den Routen mit kü Wegen definieren, sondern wird zusä von einer zeitlichen Be- schrä beeinflusst. Auch dieses kombinatorische Problem ist N P-schwer und ist als Erweiterung des klassischen VRP eine sehr hä vorkommende Problemstellung im Bereich der Logistik, wo es neben der Belieferung aller Kunden mit minima- len Kosten nun auch zu berü gilt, dass jeder Kunde nur innerhalb eines Zeitfensters [a i , b i ] beliefert werden kann, wobei a i der frü und b i der spä Zeitpunkt ist, zu dem Kunde i beliefert werden kann.</p><p>Da das Ziel die Minimierung des notwendigen Zeitaufwandes ist, muss die Dreiecksun- gleichung in konkreten Szenarien meist nicht erfü werden, da kü Strecken nicht immer gleichbedeutend mit kü Zeitaufwand sind. Das heißt, dass t ij +t jk ≥ t ik , wobei t ij den Zeitaufwand fü die Strecke von Kunde i zu Kunde j bezeichnet, in diesem Fall nicht zwingend gilt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generalisierte Netzwerkprobleme</head><p>Zur Klasse der Netzwerkprobleme zä man unter anderen das Minimum Spanning Tree Problem, das Traveling Salesman Problem sowie das Problem kü Wege. Allgemein besteht die Aufgabe bei einem Netzwerkproblem darin, einen optimalen Teilgraphen F eines Graphen G unter Einhaltung gewisser Randbedingungen zu fin- den. Wenn man nun von Generalisierten Netzwerkproblemen spricht, so werden dabei die Knoten des Graphen G in Gruppen (engl.: Cluster) eingeteilt und die Randbe- dingungen auf dieser Basis formuliert. Hier kann dann beispielsweise ein minimaler Spannbaumüber Spannbaumü alle Cluster oder ein Hamiltonkreis (siehe dazu auch Kapitel 3.3) fü alle Cluster gesucht werden.</p><p>Formal ist bei einem Generalisierten Netzwerkproblem ein (un)gerichteter Graph G = (V, E), bestehend aus einer Menge von Knoten V = {1, . . . , n} und der Kantenmenge E ⊆ {(i, j) : i, j ∈ V }, gegeben. E(S) = {(i, j) ∈ E : i, j ∈ S} sei dann jene Teilmenge von Kanten, die ihre Endpunkte in S ⊆ V haben. Je nachdem welche Randbedingungen definiert werden, entsteht ein entsprechendes konkretes Problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Traveling Salesman Problem</head><p>Beim sogenannten Traveling Salesman Problem (TSP) <ref type="bibr" target="#b2">[1]</ref> handelt es sich um ein wei- teres kombinatorisches Optimierungsproblem, das in der Klasse der N P-vollstä- gen Probleme enthalten ist. Das Ziel hierbei ist es, alle vorhandenen Orte innerhalb einer Rundreise, bei der also der Startort gleich dem Zielort ist, zu besuchen und dabei eine mö kurze Strecke zu finden.</p><p>Um dieses Problem in ein mathematisches Modell zu bringen, bietet sich dië Uber- setzung in ein graphentheoretisches Problem an, wobei die Orte den Knoten und die Verbindungen der Orte den Kanten des Graphen entsprechen. Jede Kante besitzt ei- ne bestimmte Lä, womit die mit ihrer Verwendung verbundenen Kosten definiert sind. Gesucht ist nun eine Tour, welche ein Kreis im Graphen ist, der jeden Knoten genau einmal enthä. Eine solche Tour wird auch Hamiltonkreis genannt.</p><p>Der Einfachheit halber wird fü dieses Problem meist angenommen, dass der zugrun- de liegende Graph vollstä ist, also je zwei Knoten durch eine Kante verbunden sind. Sollte der Graph nicht vollstä sein, kann man sich dadurch helfen, die feh- lenden Kanten einzufü und mit so hohen Kosten zu belasten, dass sie in einer minimalen Tour nicht vorkommen wü, es sei denn es wä sonst keine Tour auffindbar. Allerdings ist dann zu beachten, dass mö unlö Instan- zen durch diese Anpassung lö werden. Die Komplexitä des Suchraumes unter</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Bekannte Lösungsansä</head><p>Berü der Anzahl n an Knoten im Graphen ist dabei in O(n n ).</p><p>Das </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Kü Wege in einem Graphen</head><p>Ein gutes Beispiel fü Dynamische Programmierung bietet der Algorithmus fü kü- zeste Wege in einem Graphen, welcher 1959 von Dijkstra <ref type="bibr" target="#b7">[6]</ref> vorgestellt wurde. Ge- 15 geben sei ein Graph G = (V, E), bestehend aus einer Menge V = {v 1 , v 2 , . . . , v n } von Knoten und einer Menge E von Kanten. Weiters bezeichne e ij eine Kante von v i nach v j und c ij deren Kosten. Der Algorithmus von Dijkstra berechnet in diesem Graph den jeweils kü Weg von einem Knoten v start ∈ V zu allen anderen Knoten v ∈ V .</p><p>Anfangs wird fü jeden Knoten im Graph dessen initial bekannte Distanz zum An- fangsknoten mit</p><formula xml:id="formula_3">w(V start ) = 0 und w(V i ) = ∞ V i ∈ V, i = start</formula><p>festgehalten. Ausgehend vom ersten Knoten V start des Weges und beginnend mit die- sem wird nun jeweils immer ein Knoten V f " fixiert" und alle direkten Nachfolger zur Fixierung vorgemerkt, also " markiert". Dabei wird fü jeden Knoten</p><formula xml:id="formula_4">V i die Distanz w(V i ) aktualisiert mit w(V i ) = min{w(V i ), w(V f ) + c if }</formula><p>und damit bestimmt, ob ein kü Weg bis zum Knoten V i existiert. Wenn alle Nachfolger von V f in dieser Form bearbeitet wurden, wird der nä davon fixiert und dessen Nachfolger untersucht. Ein Knoten, der bereits fixiert wurde, wird nicht mehr aktualisiert. Durch dieses Vorgehen nä man sich Schritt fü Schritt dem Zielknoten. Sobald dieser fixiert wird, hat man das Ende erreicht und einen optimalen Weg gefunden. Die Rekonstruktion des Weges ist durch Rü Rückverfolgungü die Gleichung</p><formula xml:id="formula_5">w(V i ) + c ij = w(V j )</formula><p>einfach mö, womit sich natü auch mehrere mö kü Wege ergeben kö.</p><p>Anhand dieses ursprü von Dijkstra vorgestellten Algorithmus ist es daher mö, durch schrittweises Lö voneinander abhä Teilprobleme in einem Graphen den kü Weg zwischen zwei Knoten zu bestimmen, sofern dieser exis- tiert.</p><p>Die Dynamische Programmierung folgt also einer einfachen Strategie: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Variable Nachbarschaftssuche</head><p>Variable Nachbarschaftssuche (VNS) ist eine vergleichsweise junge Metaheuristik, die ihren Ursprung um das Jahr 1995 hat, in dem sie erstmalig vorgestellt wurde (siehe <ref type="bibr" target="#b17">[16]</ref> und <ref type="bibr" target="#b12">[11]</ref>).</p><p>Grundsä kann ein Optimierungsproblem allgemein formuliert werden als</p><formula xml:id="formula_6">min {f (x)|x ∈ X, X ⊆ Z}. (5.1)</formula><p>Z, X, x und f bezeichnen dabei den Lö, die Menge der gü Lö, eine konkrete Lö und eine Funktion, die jeder Lö x ∈ X einen reellen Zielfunktionswert zuordnet. Meist ist eine explizite Durchsuchung von X auf Basis von (vollstä) Enumerationsverfahren nicht applikabel. Zudem sind viele der in der Praxis relevanten Probleme N P-schwer, was impliziert, dass die Existenz eines polynomiellen Algorithmus zur Lö dieser Probleme hö unwahrscheinlich ist.</p><p>Daher kommen hä (Meta-)Heuristiken zum Einsatz.</p><p>VNS bietet dabei ein sehr einfach gehaltenes Verfahren mit vielen Ausbaumö- keiten und folgt dem einfachen Prinzip, bereits vorhandene Lö einer leichten Verä zu unterziehen, um somit neue, mö bessere, Lö zu erhalten. Um dabei systematisch vorgehen zu kö, werden so genannte Nachbar- schaften definiert, welche im Wesentlichen auf Rechenvorschriften basieren, wie eine vorhandene Lö abzuä ist, um neue, mö bessere, zu erreichen.</p><p>Sei N = {N 1 , . . . , N kmax }, k max ≥ 1, als endliche Menge vorgegebener Nachbar- schaftsstrukturen, sowie N k (x) als Menge der Lö der k-ten Nachbarschaft von x definiert. Als globales Optimum wird jene Lö x opt bezeichnet, fü die</p><formula xml:id="formula_7">x opt = min {f (x)|x ∈ X, X ⊆ Z} gilt. Ein lokales Minimum x ∈ X in Bezug auf N k ist gegeben, wenn es keine Lö x ∈ N k (x ) ⊆ X mit f (x) &lt; f (x ) gibt.</formula><p>Die Variable Nachbarschaftssuche beruht auf folgenden drei einfachen Tatsachen <ref type="bibr" target="#b13">[12]</ref>:</p><p>(i) Ein lokales Minimum bezü einer Nachbarschaftsstruktur ist nicht notwen- digerweise auch ein lokales Minimum bezü einer anderen.</p><p>(ii) Ein globales Minimum muss gleichzeitig ein lokales Minimum bezü aller Nachbarschaftsstrukturen sein. Der letzte Punkt basiert auf vorhandenen Erfahrungswerten und lä in vielen Fä Rückschlü von einem lokalen auf das globale Optimum zu.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Lokale Suche und Shaking</head><p>Lokale Suche mittels Variable Neighborhood Descent Unter lokaler Suche ver- steht man ein Verfahren, bei dem der Lö in einem begrenzten Bereich in der Umgebung einer gü Lö durchsucht wird. Der zu durchsuchende Bereich wird durch die Nachbarschaft dieser Lö vorgegeben. Das bedeutet, dass durch festgelegte Rechenvorschriften Adaptionen der Ausgangslö vorgenommen wer- den und auf diesem Weg neue Lö erreicht werden. Um entscheiden zu kö, ob eine Lö besser oder schlechter ist, wird eine Bewertungsfunktion verwendet.</p><p>In Abb. 5.1 ist der Verlauf einer mö Zielfunktion dargestellt, sowie die Posi- tion x start einer Startlö markiert, von welcher ausgehend innerhalb einer Nach-</p><formula xml:id="formula_8">barschaft N i beispielsweise alle Lö im Intervall [x i ; x start ] oder innerhalb ei- ner Nachbarschaft N j alle Lö im Intervall [x start ;</formula><p>x j ] erreichbar sind und die markierten lokalen Optima hierbei jeweils die besten Lö der Nachbarschaften darstellen.</p><p>Bei der konkreten Umsetzung der lokalen Suche durch den Variable Neighborhood Descent (VND) wird der Lö Lösungsraumü alle Nachbarschaftsstrukturen determi- nistisch durchsucht. Ausgangspunkt sind eine vorhandene Startlö sowie die vor-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Lokale Suche und Shaking</head><p>definierte Reihenfolge der verfü Nachbarschaftsstrukturen. Beginnend bei der ersten Nachbarschaft der Startlö wird nun nach einer besseren Lö gesucht, um auf Basis dieser die Suche fortzusetzen. Die Reihenfolge in der die Nachbarschaf- ten einer Lö durchsucht werden hä davon ab, ob Verbesserungen gefunden werden kö oder nicht. Wird Nachbarschaft N i durchsucht und konnte eine Ver- besserung erzielt werden, so wird die Suche mit Nachbarschaft N 1 fortgesetzt. Kann in N i keine Verbesserung erzielt werden, so kommt Nachbarschaft N i+1 zum Einsatz. Der Algorithmus terminiert also erst, wenn keine weiteren Verbesserungen erzielt werden kö. Auf diesem Weg werden alle Nachbarschaften durchsucht, wobei am Beginn der Kettë ublicherweise jene Strukturen stehen, deren Definition ein schnel- leres Durchsuchen erlaubt als bei spä gereihten. In diesem Zusammenhang seien zwei Strategien erwä, anhand derer entschieden werden kann, wann das Durch- suchen einer Nachbarschaft beendet werden soll. Wird Best Improvement (fü die beste Lö einer Nachbarschaft) gewä, dann werden die Nachbarschaften, wie eben beschrieben, komplett durchsucht. Unter Verwendung von Next Improvement (fü die nä bessere Lö einer Nachbarschaft) wird die Suche innerhalb einer Nachbarschaft abgebrochen, sobald eine bessere Lö gefunden werden konnte. Der erste Eindruck mag vermitteln, dass es fü die Lö Lösungsverbesserungü alle Nachbarschaften besser wä diese stets komplett zu durchsuchen. Tatsä ist es aber schwierig zu beurteilen welche Lö fü nachfolgende Nachbarschaften grö- res Optimierungspotential bietet. Sicher jedoch kann behauptet werden, dass Next Improvement kü Laufzeit hat als Best Improvement, sofern mindestens einmal abgebrochen werden kann, bevor eine Nachbarschaft komplett durchsucht wurde.</p><p>In Alg. 1 ist der Ablauf von VND dargestellt. Natü ist zu beachten, dass sich abhä von der Anzahl der definierten Nachbarschaftsstrukturen auch die Laufzeit verä. Eine grö Anzahl an Nachbarschaftsstrukturen erhö den notwendigen Zeitaufwand, steigert aber gleichzeitig auch die Chance eine bessere Lö zu finden.</p><p>Shaking Zusä zur lokalen Suche kann der Einsatz von zufä Komponenten positiven Einfluss auf die Effizienz eines Algorithmus haben. Dies kann durch einen so genannten Shaking-Mechanismus erreicht werden, also einem zufä " Durch- schü", wodurch zufä Verä einer Lö eine neue Lö erzeu- gen. Angenommen alle vorhandenen Nachbarschaftsstrukturen alleine ermö lediglich von der in Abb. 5.1 markierten Startlö x start aus innerhalb des In- tervalls [x i ; x j ] neue Lö zu finden, so wü dies bedeuten, dass die besten auffindbaren Lö die beiden gekennzeichneten lokalen Optima wä. Durch das Shaking kann man allerdings erreichen, dass dieses Intervall verschoben wird und somit in einem neuen Bereich der Zielfunktion nach Optima gesucht werden kann, womit die Wahrscheinlichkeit steigt, das globale Optimum zu finden.</p><p>Bei der lokalen Suche handelt es sich also um einen Prozess, der innerhalb eines definierten Teilbereichs des gesamten Lö nach besseren Lö sucht. Die Definition von zu durchsuchenden Teilbereichen (Nachbarschaften) ist allerdings</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 1 : VND</head><p>Input : eine Startlö x start fü das Optimierungsproblem Output : die beste gefundene (lokale) Lö x Data : sei N eine endliche Menge vorgegebener Nachbarschaftsstrukturen</p><formula xml:id="formula_9">begin k ← 1 ; x ← x start ; repeat Suche nach bestem Nachbarn x der Lö x innerhalb der k-ten Nachbarschaft (x ∈ N k (x)) ; if f (x ) &lt; f (x) then x ← x ; k ← 1 ; else k ← k + 1 ; until k = k max ; return x ; end</formula><p>abhä von der aktuellen Lö. Somit stellt sich natü stets die Frage, ob mit den zur Verfü gestellten Nachbarschaften der gesamte Lö erreicht werden kann, beziehungsweise vor allem die optimale Lö. Um nun auch mö- cherweise nicht abgedeckte Bereiche des Lö erreichen zu kö, wird Shaking eingesetzt. Erzeugt werden diese Verä durch zufä Generieren von Lö aus einer der Nachbarschaften der aktuellen Lö.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Genereller Ansatz fü die Variable Nachbarschaftssuche</head><p>Aus der Kombination von lokaler Suche und Shaking lä sich nun der generelle Ansatz fü VNS aufbauen. Dabei wird die lokale Suche eingebettet in einen wieder- kehrenden Ablauf von Shaking und der Entscheidung darü, ob mit einer neuen und besseren Lö fortgesetzt wird, oder keine Verbesserung innerhalb der lokalen Suche mö war. Diese Vorgehensweise wird in Alg. 2 gezeigt. Es handelt sich hier um die Grundstruktur einer VNS, wobei die allgemein als lokale Suche bezeichnete Phase durch VND abgedeckt wird. Darü hinaus bildet dieser Ablauf zugleich das Grundgerü der in dieser Arbeit angewandten Nachbarschaftssuche.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>20</head><p>Algorithmus 2 : Genereller VNS-Ansatz Input : eine Startlö x start fü das Optimierungsproblem Output : die beste gefundene Lö x Data : sei N eine endliche Menge vorgegebener Nachbarschaftsstrukturen Aus diesem Grund schien es sinnvoll zu sein, metaheuristische Verfahren in Kom- bination mit exakten Methoden zur Lö von Teilaufgaben beziehungsweise zur Bewertung von konkreten Lö zu verwenden. Durch den Einsatz von VNS als Metaheuristik ist es mö in kurzer Zeit sehr viele unterschiedliche Lö zu er- zeugen. Dabei werden zunä gewisse Parameter ermittelt, die eine konkrete Lö definieren. Allerdings muss diese auch bewertet werden, um deren Gü bestimmen zu kö. Dies geschieht mittels Dynamischer Programmierung in einem weiteren Schritt des Algorithmus, in welchem auf Basis der durch die VNS vorgegebenen Pa- rameter einer Lö eine passende konkrete Tour durch das Lager berechnet wird.</p><formula xml:id="formula_10">begin k ← 1 ; x ← x start ; repeat // Shaking: Erzeuge eine zufä Lö x aus x innerhalb der k-ten Nachbarschaft (x ∈ N k (x)) x ← shake(x, k) ; // Fü lokale Suche mittels VND durch x ← V N D(x ) ; if f (x ) &lt; f (x) then x ← x ; k ← 1 ; else k ← k + 1 ; until k = k max ; return x ; end</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Der grundsä Ablauf</head><p>Der in dieser Arbeit entwickelte Algorithmus kann im Wesentlichen in vier Teilberei- che gegliedert werden, welche so lange wiederholt werden bis keine zu bearbeitenden Bestellungen mehr vorhanden sind: </p><formula xml:id="formula_11">1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Partitionierung vorhandener Bestellungen</head><p>Wie bereits erwä wurde, handelt es sich bei diesem Teil des Ablaufs um eine erste Auswahl aus den vorhandenen Bestellungen. Es gibt also sozusagen einen Contai- ner, der mit Bestellungen von Seiten der Kunden befü wird. Aus diesem werden dann jeweils die nä zu bearbeitenden ausgesucht und an die folgenden Phasenübergeben</p><p>Phasenü. Um die Anforderungen an die mö kurz zu haltenden Lieferzeiten einhalten zu kö, werden die verfü Bestellungen nach deren Lieferdatum geordnet. Zusä wird berü, dass Artikel einer Bestellung im selben Be- reich der Verdichtungszone abgelegt werden mü und die damit verbundenen Ka- pazitätsbeschrä einzuhalten sind. Die Auswahl wird daher so getroffen, dass eine Partitionierung in ihrer Gesamtheit einen einzigen Bereich der Verdichtungszo- ne erreicht. Es ist natü ersichtlich, dass es sich bei dieser Vorgehensweise nur um einen mö Ansatz handelt, mit diesen Randbedingungen beziehungsweise mit im Verlauf des Arbeitstages eintreffenden Bestellungen umzugehen. Es wird hier- bei kein Anspruch auf Optimalitä des Verfahrens gestellt, alle Nebenbedingungen werden dabei allerdings erfü.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Zuordnung von Artikeln zu Touren</head><p>Obwohl dieser Schritt des Algorithmus hauptsä die Entscheidung trifft welche der bestellten Artikel innerhalb einer Tour eingesammelt werden sollen, erfolgt die Bewertung dessen auf Basis der Lä von konkreten Touren und das macht be- reits hier die Berü mehrerer Einschrä notwendig. So auch bei Artikeln mit mehreren Lagerplä. Hier muss entschieden werden welche Menge von welchem Platz abgeholt werden soll, wobei natü auch die Kapazitä der Kommissionierungswagen nichtüberschritten nichtü werden darf.</p><p>Eine Lö x fü die Zuordnung von Artikeln zu Touren muss also mehrere Infor- mationen beinhalten, welchë uber die Menge S der Zuordnungen von Artikeln zu Touren bestimmt sind. Das ist zunä die Information, welche Mengen</p><formula xml:id="formula_12">k 1 , . . . , k j ⊆ N j</formula><p>fü jeden Artikel a j ∈ A einzusammeln sind, wobei A die Menge der Artikel bezeich- net (|A| = j) und j maximal gleich der Anzahl an unterschiedlichen Lagerplä fü den Artikel a j sein kann. Weiters wird definiert von welchen Lagerplä </p><formula xml:id="formula_13">l 1 , . . . , l j ⊆ L j diese entnommen</formula><formula xml:id="formula_14">m S = {S i } (7.1) i=1 S i = {1, . . . , s i }, mit i ≥ 1 (7.2) s j = a j , l 1 , . . . , l j , k 1 , . . . , k j , mit j ≥ 1 (7.3)</formula><p>Zusä sei T i definiert als ein konkreter Weg durch das Lager, auf welchem die durch S i implizierten Lagerplä besucht werden. Die Menge</p><formula xml:id="formula_15">m T = {T i } (7.4) i=1</formula><p>bildet dann die Menge aller Touren T i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Konstruktionsheuristiken</head><p>Aufgrund der Tatsache, dass der Algorithmus ausgehend von einer Startlö vie- le unterschiedliche Lö erzeugen und untersuchen soll, ist es notwendig einen schnellen Startpunkt zu generieren, was mittels Initialisierung per Konstruktionsheu- ristiken geschieht. Ausgehend davon kann dann in der Folge die vorhandene Lö weiter verbessert werden. Da die Anzahl der gegebenen und zu erfü Nebenbe- dingungen groß ist, bot sich die Entwicklung zweier unterschiedlicher Konstruktions- heuristiken an, von denen beide jeweils unterschiedliche Mengen von Einschrä- gen abdecken.</p><p>Die erste dieser Heuristiken, die so genannte Collision Avoiding Heuristic (CAH), baut auf der Idee auf eine Menge von Touren erzeugen zu kö, die nichtüber nichtü- 28</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Zuordnung von Artikeln zu Touren</head><p>Algorithmus 4 : CollisionAvoidingHeuristic Input : eine Liste bestellter Artikel; Anzahl der Zonen m Output : eine Menge von Mengen bestehend aus einzusammelnden Artikeln innerhalb von m Touren Data : Menge S von Mengen S i , mit i = 1 . . . m, von einzusammelnden Artikeln begin foreach S i ∈ S do S i ← ∅ ; fü alle in Zone Z i bestellten Artikel zu S i hinzu ; return S ; end lappen. Es sollen dabei also keine Kreuzungen auftreten, sodass Arbeiter auf ihrem Weg durch das Lager nicht kollidieren. Um das zu erreichen, wird das Lager in m (physisch) nichtüberlappende nichtü Zonen Z i , mit i = 1, . . . , m, eingeteilt. Nun wird fü jede solche Zone Z i eine Tour T i errechnet, um alle Artikel einzusammeln, welche in Zone Z i gelagert sind. Der Parameter m kann nach Belieben gewä werden, es bietet sich aber durchaus an ihn mit der Anzahl der verfü Lagerarbeiter zu initialisieren. Der Ablauf dieser Heuristik wird in Alg. 4 skizziert.</p><p>Die zweite Konstruktionsheuristik, Time Saving Heuristic (TSH) genannt, versucht anhand der streng einzuhaltenden Liefertermine entsprechende Zuordnungen zu fin- den. Erreicht wird dies hierbei, indem zunä eine Reihung der Bestellungen nach deren spä mö Lieferzeitpunkten erstellt wird, um anschließend mittels First-Fit Verfahrens Touren T i , mit i = 1, . . . , m, zu berechnen, sodass die ersten benö und auszuliefernden Artikel in Tour T 1 eingesammelt werden. Erst wenn die Kapazitä des ersten Kommissionierungswagens nicht mehr ausreichen sollte, wird eine zweite Tour T 2 fü weitere Artikel erzeugt. Analog dazu entstehen eventu- ell benö weitere Touren T 3 , . . . , T m . Der Pseudo-Code fü diesen Ablauf wird in Alg. 5 gezeigt.</p><p>Es ist offensichtlich, dass diese beiden Heuristiken alleine noch nicht ausreichen, um zulä Lö des Problems zu produzieren. Bei CAH kann nicht zugesichert werden, dass etwa Lieferzeiten eingehalten werden und darü hinaus werden die Ka- pazitä der Kommissionierungswagen nicht beachtet. Andererseits kann bei TSH nicht garantiert werden, dass die Touren nichtüberlappen nichtü. Daher kann nur dann mit diesen Methoden gearbeitet werden, wenn zusä Reparaturalgorithmen zum Einsatz kommen. Trotzdem soll angenommen werden, dass die vorerst gefundenen Lö als ad hoc-Antwort durchaus akzeptabel sind, etwa wenn das System im Betrieb morgens gestartet wird. Der Hintergedanke dabei ist, dass fü jeden einzelnen Mitarbeiter zunä nur die Informationüber Informationü den nä zu holenden Artikel von Bedeutung ist. Alle weiteren Artikel kö bestimmt werden wä der Mitar-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>29</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 5 : TimeSavingHeuristic</head><p>Input : eine Liste L bestellter Artikel a i Output : eine Menge von Mengen bestehend aus einzusammelnden Artikeln innerhalb von m Touren Data : Menge S von Mengen S i , mit i = 1 . . . m, von einzusammelnden Artikeln; m wird durch diesen Algorithmus bestimmt begin sortiere die Elemente in L nach dem spä Lieferdatum; S ← ∅ ; i ← 1 ;</p><formula xml:id="formula_16">S i ← ∅ ; foreach a ∈ L do if a passt nicht in S i then S ← S ∪ {S i } ; i ← i + 1 ; S i ← ∅ ; fü a zu S i hinzu ; S ← S ∪ {S i } ; return S ; end</formula><p>beiter mit den ersten Artikeln beschä ist. Damit hat das System Zeit, um weitere Rechenschritte durchzufü und verbesserte Lö fü dië ubrigen Routen zu finden. Artikel, die bereits eingesammelt wurden, mü fix in den jeweiligen Touren eingeplant bleiben und nur nachfolgende Artikel sind in der Reihenfolge der Abholung noch variabel.</p><p>Auch wenn die Lö x, gefunden von CAH oder TSH, gü ist, heißt das noch nicht, dass deren Gü f (x), im Speziellen also die Lä aller dadurch errechneten Touren insgesamt, die bestmö ist. Generell kann man aber davon ausgehen, dass dermaßen erzeugte Lö relativ schlechte Bewertungen haben werden. Der Grund dafü sind die Bestrafungen, die durch ein¨Uberfüllen ein¨Uberfü von Kommissionierungs- wagen entstehen. Sobald die Kapazitä eines solchen erreicht wird, bestraft der Algorithmus dies so stark, dass es auf alle Fä eine gü Lö ist einen zusä Wagen zu verwenden. Es wird also unerlä sein mit Verbesserungs- heuristiken weiterzuarbeiten.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Reparatur-und Verbesserungsheuristik</head><p>Zentraler Bestandteil des Programms ist die Umsetzung einer Variablen Nachbar- schaftssuche (VNS) <ref type="bibr" target="#b13">[12]</ref> mit Verwendung des Variable Neighborhood Descent (VND) als lokale Verbesserungskomponente, welche sowohl als Reparatur-als auch als Ver-besserungsheuristik eingesetzt werden kann. Zur Reparatur ist das Verfahren ein- setzbar, weil durch hohe Bestrafung von ungü Lö stets eine bessere, also kostengü und gleichzeitig vor allem gü Lö gefunden werden kann. Wesentlich hierbei ist die Verä der Artikelauswahlen, die in weiterer Folge erst die Tourberechnung beeinflusst. Die nachfolgende Auflistung bezieht sich also stets auf eine Adaptierung von Artikelauswahlen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Folgend den bereits in Kapitel 5 dargelegten</head><note type="other">Erlä, kommen die anschließend vorgestellten Nachbarschaftsstrukturen zum Einsatz. Da diese Strukturen auf Basis von grundlegenden Moves definiert werden, folgt zuvor eine Auflistung eben dieser:</note><formula xml:id="formula_17">SwapMove(i, j, k, l) Dieser Schritt tauscht die Artikel k ∈ S i und l ∈ S j , mit S i , S j ∈ S, 1 ≤ i &lt; j ≤ m und k = l.</formula><p>Das bedeutet, dass nach Anwendung dieses Schrittes Artikel k von Tour S i entfernt und Artikel l eingefü wurde. Analog wurde Artikel l von Tour S j entfernt und Artikel k eingefü.</p><formula xml:id="formula_18">ShiftMove(i, j, k) Wird dieser Schritt durchgefü, so bedeutet dies, dass Artikel k ∈ S i aus S i entfernt und in S j eingefü wird, wobei 1 ≤ i, j ≤ m und i = j.</formula><p>MergeMove(i, j) Bei diesem Schritt werden zwei Touren S i und S j zu einer neuen Tour S i zusammengefü. Es werden also all jene Artikel, die zuvor von S i und S j eingesammelt wurden, von einer neuen Tour bearbeitet, wodurch S i und S j aus der Menge S entfernt werden kö und stattdessen S i in S eingefü wird. Es vermindert sich dadurch also die Anzahl der Touren um eins.</p><p>SplitMove(i, R) Die Anwendung dieses Schrittes bringt die Tour S i zu einer Auftei- lung in zwei neue Touren S i und S i , indem alle in R enthaltenen Artikel von S i nach S i verschoben werden. S i muss dann natü zu S hinzugefü werden und somit erhö sich die Gesamtzahl an Touren um eins.</p><p>Formal betrachtet hat man hier 2 s Mö die ursprü Tour zu zerlegen, wenn die Anzahl an Elementen in S i mit s bezeichnet wird, also |S i | = s. Die Zerlegungen berechnen sich dann aus der Potenzmenge von S i , nä P(S i ), beziehungsweise ergibt das |P(S i )| = 2 s verschiedene Mö.</p><p>SwapPositionMove(i, k, l) Dieser Move nü die Tatsache aus, dass Artikel an mehr als nur einer Position im Lager verfü sein kö. Sollte an einer weiteren Position im Lager ein bestimmter Artikel in der benö Menge vorhanden sein, so kann die Position vertauscht werden. Es wird dann der Ort des Artikels k ∈ S i auf den neuen Ort l geä. Um den Ablauf hierbei ein- fach zu halten, wird der Artikel aus der Tour S i entfernt und eine neue Tour S i gebildet, die zunä nur diesen einen Artikel k mit der neuen Lagerplatz- information enthä. Durch die spä Anwendung eines MergeMove kö diese Tour mit einer anderen wieder zusammengelegt werden.</p><p>SplitPositionMove(i, k, l, q) Dieser Schritt ermö es in etwas anderer Form als bei den beiden bisherigen Varianten einen Artikel von anderer Stelle einzusam-meln. Es ist generell natü nicht nur mö die komplette Menge eines angeforderten Artikels von einem anderen Lagerplatz zu holen, sondern bei Bedarf auch nur eine Teilmenge davon. Diese Tatsache erlaubt die Definiti- on eines Moves, durch den aus der Tour S i eine bestimmte Teilmenge q fü den Artikel k von einer zusä Position l im Lager innerhalb einer neuen Tour S  </p><note type="other">i eingesammelt wird und gleichzeitig eine bleibende Restmenge von der ursprü Position zu holen bleibt. Aus diesen grundlegenden Moves werden nun folgende Nachbarschaftsstrukturen de- finiert, wobei S die Menge an Selektionen (Touren) bezeichnet, s max die maximale (grö vorkommende) Anzahl an Artikeln einer Tour angibt und l max fü die maxi- male (grö vorkommende) Anzahl an alternativen Lagerplä eines Artikels aus dem Lager steht: Swap Grundlage fü diese Nachbarschaftsstruktur ist der zuvor eingefü Swap- Move.</note><note type="other">zufä generierte Lö zu testen, um die Komplexitä der Nachbarschafts- struktur zu umgehen. Das komplette Durchsuchen dieser, wie auch einiger der folgenden Nachbarschaftsstrukturen wü zu lange dauern. Es schien durchaus vertretbar an dieser Stelle mit einer Zufallskomponente zu arbeiten. MultipleShift¨Ahnlich wie beim zuvor beschriebenen DoubleShiftMove, ist auch hier eine Aneinanderreihung von Elementen aus ShiftMoves Gegenstand der Defini- tion, allerdings ist die Anzahl an Verschiebungen hier frei definierbar. Dement- sprechend definiert sich die Grö der mö Lö hier</note><formula xml:id="formula_19">begin l ← 1 ; repeat x ← durchsuche Nachbarschaft N l (x) ; if f (x ) &lt; f (x) then x ← x ; l ← 1 ; else l ← l + 1 ;</formula><p>until l &gt; l max oder eine vordefinierte Zeit wurde erreicht ; end tung einer Lö x und einer daraus abgeleiteten mö Verbesserung x . Da die Gü einer Lö im Wesentlichen von der Summe der Lä aller Touren abhä, ist es also hier von Bedeutung sä benö Touren einer Lö so zu berechnen, dass diese auf kü Weg durch das Lager fü. Kapitel 7.3 wird zeigen wie es mö ist entsprechende Touren unter Berü der speziellen Eigenschaften des Lagers in polynomieller Zeit zu berechnen.</p><p>Die Nachbarschaftsstrukturen zur Durchfü von Shaking-Phasen (also zufä Verä einer Lö) basieren auf den zuvor vorgestellten, jedoch werden hierbei anstelle eines Schrittes mehrere zufä ausgewä Schritte auf die entspre- chende Lö angewendet. In der letzten Version des Algorithmus kam dafü Swap zum Einsatz. Die zufä Verä aus der Nachbarschaft N k (x) in Alg. 2 kommen daher jeweils nur aus Swap. Gleichermaßen wä aber auch die Verwendung von Shift, Split oder Merge sowie jede Kombination dieser mö gewesen, jedoch konnten keine klaren Vorteile fü eine der Varianten im Vorfeld ausgemacht werden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.3">Durchsuchen der Nachbarschaften</head><p>Beim Durchsuchen der einzelnen Nachbarschaften unterscheidet man zwei Methoden zur¨Ubernahme einer neuen und besseren Lö, nä Next Improvement und Best Improvement (siehe auch Kapitel 5). Wird Next Improvement verwendet, so ist das gleichbedeutend mit einem Abbruch der Suche, sobald eine bessere Lö gefun- den wurde. Konkret auf ShiftMove bezogen wird also die Nachbarschaft systematisch durchsucht und beginnend mit dem ersten bis zum letzten Artikel versucht diesen einer anderen Tour zuzuordnen. Bei diesem Vorgehen sind aber jene Artikel klar bevorzugt, welche in der Liste am Anfang stehen. Daher wurde eine zufä Durch- suchungsreihenfolge implementiert, sodass jede Lö im Nachbarschaftsraum mit gleicher Wahrscheinlichkeit zu einer Verbesserung beitragen kann.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.4">Dynamische Reihenfolge der Nachbarschaften</head><p>Eine große Herausforderung bei der Umsetzung mittels VNS stellt die Reihung der definierten Nachbarschaftsstrukturen dar. Nachdem die Anwendung einer Nachbar- schaftsstruktur durchaus auch Auswirkungen auf die Effizienz nachfolgender Nach- barschaftsstrukturen hat, ist diese Entscheidungsfindung nicht trivial. Aus diesem Grund wurde entschieden, eine Adaptierung der in <ref type="bibr" target="#b15">[14]</ref>  Das Konzept ist in Alg. 7 ersichtlich, wobei eine kleine Anpassung zum in <ref type="bibr" target="#b15">[14]</ref> vor- gestellten Algorithmus durchgefü wurde, um zu vermeiden, dass Nachbarschaften ausgelassen werden kö. Das kann vorkommen, da dort vor jeder Umreihung ge- speichert wird mit welcher Nachbarschaft fortgesetzt werden soll und diese dann wei- ter hinten gereiht werden kö als andere noch nicht besuchte. Außerdem soll ver- hindert werden, dass die Nachbarschaften stä umgereiht werden. Dies geschieht im ursprü vorgestellten Verfahren viel hä, da auch dann eine Umreihung passieren kann, wenn keine Verbesserung der Lö erzielt wurde. Der tatsä verwendete Algorithmus verä die Reihenfolge der Nachbarschaften erst dann, wenn gerade eine verbesserte Lö gefunden werden konnte.</p><p>Getestet wurde der gesamte Algorithmus sowohl mit dynamischer als auch mit stati- scher Nachbarschaftsreihenfolge. Die Ergebnisse dazu werden in Kapitel 8 prä.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 7 : VND mit dynamischer Nachbarschaftsreihenfolge</head><p>Input : eine Startlö x Data : Zä i, Anzahl k der zu untersuchenden Nachbarschaften</p><formula xml:id="formula_20">begin w 1 ← w 2 ← . . . ← w k ← W ; w min ← w max ← W ; λ = (1, 2, . . . , k) ; i ← 1 ; repeat x ← durchsuche Nachbarschaft N i (x) mit Zeitaufwand t λ i ; if f (x ) &lt; f (x) then x ← x ; w λ i ← w λ i 2 + t λ i α ; if (w λ i &lt; w min ) ∨ (w λ i &gt; w max ) then Sortiere λ 1 , . . . , λ k , sodass w λ 1 ≤ w λ 2 ≤ . . . ≤ w λ k ; w min ← w λ 1 ; w max ← w λ k ; i ← 1 ; else w λ i ← w λ i + t λ i ; i ← i + 1 ; until i &gt; k ; end</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 8 : Berechnung einzelner Touren</head><p>Input : Menge an Zuordnungen S Data : m = |S| Output : Menge von Touren T begin foreach S i ∈ S do T i ← kü Tour fü S i ; T ← T ∪ {T i } ; return T ; end</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Berechnung einzelner Touren</head><p>Die nachfolgende Phase des Algorithmus, wie in Alg. 3 vorgestellt, betrifft das Auffin- den von Touren ausgehend von den zuvor festgelegten Artikelzuordnungen. Weiters ist die Berechnung von kü Wegen ein Teilproblem des VNS, wie in Kapi- tel 7.2.2 beschrieben.</p><p>Zur effizienten Berechnung dieser Touren ist es zunä notwendig das Lager in eine passende Struktur zu dessen Reprä zu bringen, was durch einen ungerichte- ten, zusammenhä Graphen G = (V, E) passiert. Ausgehend davon kann nun ein Verfahren basierend auf Dynamischer Programmierung nach optimalen Touren suchen. Die dabei entscheidende Idee ist die Definition so genannter Module, wel- che entsprechend ihrer Verbindungsmö aneinander angeschlossen werden kö. Der nun im Detail erlä Algorithmus berechnet fü jede Zuordnung S i eine konkrete Tour T i . Diese Vorgehensweise ist im Pseudo-Code in Alg. 8 ersichtlich.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">Reprä als Graph</head><p>Die Reprä des Lagers geschieht also mittels eines ungerichteten, zusam- menhä Graphen G = (V, E), wobei die Kantenmenge E die Gä innerhalb des Lagers bildet. Unterschieden werden dabei Regalgä und Hauptgä. Wä erstere jene Gä sind, die sich zwischen den Lagerregalen befinden und parallel zu diesen sind, verbinden zweitere Regalgä und wieder andere Hauptgä miteinan- der (siehe auch Abb. 1.1 in Kapitel 1). Jeder Knoten v ∈ V entspricht einem Punkt mit speziellen Eigenschaften. Das kö die Verdichtungszone (VZ), Kreuzungen von Gä und Positionen innerhalb von Regalen sein. Es kommt sehr hä vor, dass mehrere Positionen im Lager (Lagerplä) ¨ ubereinander liegen, solche Vorkom- men werden dann aber zusammengefasst in einem Knoten, der darü hinaus den gesamten Regalgang enthä.</p><p>Man kann nun sehen, dass jeder Knoten v ∈ V hö vier Nachbarn hat, das Unter Ausnü dieser Eigenschaften kann man den Graphen G einschrä und die Anzahl an Knoten stark reduzieren, indem fü jeden Gang hö drei Knoten existieren (siehe Abb. 7.1). Dort reprä der Knoten in der Mitte die (lineare Liste der) Lagerplä und die beiden Knoten am Beginn und am Ende des Ganges bezeichnen die Kreuzungspunkte mit dem jeweiligen Hauptgang.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.2">Ein Dynamisches Programm</head><p>Ohne Einschrä der Allgemeinheit und mit Bezug auf Abb. 7.1 soll angenommen werden, dass Regalgä und Hauptgä orthogonal zueinander liegen. Hauptgä verlaufen hierbei von oben nach unten, Regalgä stets von links nach rechts. Eine Menge von zwei Hauptgä gemeinsam mit den dazwischen liegenden Regalgä wird weiters auch als Block bezeichnet.</p><p>Im Folgenden wird ein Algorithmus aufbauend auf Dynamischer Programmierung gezeigt, welcher in polynomieller Zeit die Berechnung kü Tourenüber Tourenü alle Knoten von Interesse, also all jene Lagerplä mit einzusammelnden Artikeln, in-</p><formula xml:id="formula_21">(a) (b) (c) (d) (e) Abbildung 7.2: Grundlegende Gangoperationen. (a) (b) (c) (d) (e)</formula><p>Abbildung 7.3: Grundlegende Zwischen-Gangoperationen.</p><p>nerhalb eines Blocks durchfü.</p><p>Zu diesem Zweck werden so genannte Gangoperationen, sowie Zwischen-Gangopera- tionen eingefü. Gangoperationen werden herangezogen, um die Mö fü Wege innerhalb eines Regalganges abzudecken, wohingegen Zwischen-Gangoperati- onen Bewegungen innerhalb der Hauptgä beschreiben.</p><p>Gangoperationen In Abb. 7.2 ist die Menge an grundlegenden Gangoperationen, welche von Arbeitern durchgefü werden kö, grafisch dargestellt. Es ist offen- sichtlich, dass Gä entsprechend von links oder rechts betreten werden kö (sie- he Abb. 7.2a-7.2d), aber auch komplett ausgelassen werden kö (siehe Abb. 7.2e). Ein Gang kann natü nur dann ausgelassen werden, wenn keine Artikel daraus benö werden. In diesem Fall ist eine solche Operation also auch gü. Im im- plementierten Algorithmus kommt diese Operation nicht direkt zum Einsatz, da hier Gä weggelassen werden, wenn sie nicht betreten werden mü. Es werden dann einfach die Gä davor und danach direkt miteinander verbunden.</p><p>Zwischen-Gangoperationen Zusä zu den eingefü grundlegenden Gang- operationen werden Zwischen-Gangoperationen benö. Diese wiederum beschrei- ben welche Mö fü die Arbeiter bestehen, um sich zwischen zwei aufein- ander folgenden Gä zu bewegen (siehe Abb. 7.3). Diese Aktionen lassen einen Wechseï uber die Hauptgä zu (siehe Abb. 7.3a-7.3d). Natü kann es auch vor- kommen, dass kein weiterer Gang besucht werden muss, dann ist kein Gangwechsel mehr nö, wie in Abb. 7.3e zu sehen ist. Die Umsetzung im Programm erfolgt auch hier durch Weglassen nicht benö Gä, die theoretisch gü Gangoperati- onen sind dann nicht nö. Gangmodule Letztlich ist es hiermit mö eine Menge an so genannten Gang- modulen zu definieren, welche wiederum auf den vorgestellten grundlegenden Ope- rationen aufbauen. Daraus kann man nun jede erdenkliche Kombination erstellen, jedoch ist nicht jede davon auch gleichzeitig gü. Abb. 7.4a und 7.4b zeigen zwei gü Module. Das in Abb. 7.4c gezeigte Modul ist jedoch von vornherein ungü, da der rechte Knoten, der die Kreuzung von Regalgang und Hauptgang reprä zweimal verlassen aber nur einmal betreten wird. Das Modul in Abb. 7.4d ist im Prinzip gü, aber vom Programm zu verwerfen, weil die Lagerplä, von denen Artikel eingesammelt werden sollen (in der Abb. dunkelgrau markiert), gar nicht besucht werden.</p><p>Es sei nun definiert, dass zwei Module j und j fü die Gä i und i unterein- ander kompatibel sind, wenn die Module j und j basierend auf ihren Zwischen- Gangoperationen verbunden werden kö. Weiters ist Modul j mit Modul j " von oben" kompatibel, wenn die Zwischen-Gangoperationen von j um " nach unten" be- ziehungsweise " nach oben" zu gehen mit den entsprechenden Zwischen-Gangoperatio- nen von j zusammenpassen. Im Folgenden bezeichnet M komp (j) die Menge aller Module j , die " von oben" kompatibel mit j sind.</p><p>Einige Beobachtungen Generelles Ziel ist immer noch das Einsammeln aller ange- forderten Artikel. Nachdem bereits Selektionen an Artikeln getroffen wurden, welche jeweils innerhalb einer Tour einzusammeln sind, wird mit dem Berechnen jeder dieser Touren ein Teilziel erreicht. Zusä dazu suchen wir aber nach Touren durch das Lager, die insgesamt ein Minimum an Zeit benö sollen, weshalb eine entspre- chende Bewertung jeder Tour erfolgen muss. Diese Bewertung kann auf den zuvor eingefü Modulen zur Tourkonstruktion passieren, indem die Kosten c i (j) &gt; 0 fü jedes Modul j basierend auf den Aktionen, die ein Arbeiter in Gang i durchfü, berechnet werden. Transformiert auf den erwä Dekodierungsgraph G bedeutet das eine einfache Umlegung auf die Kosten fü jede einzelne Kante e ∈ E gemä den jeweiligen Lä derselben.</p><p>In Bezug auf die Anzahl von Modulen, die zur Zusammenstellung einer Tour relevant sein kö, muss zum einen nocheinmal erwä werden, dass nicht alle Kombina- tionen an Gangoperationen und Zwischen-Gangoperationen gü Module bilden. Zum anderen ist es aber darü hinaus wesentlich zu beachten, dass auch gü Module teilweise auszuschließen sind beziehungsweise manche gü Module durch weitaus effizientere Module mit gleichen Mö ersetzt werden kö. Als Abbildung 7.5: Ein gü Modul (a) kann durch ein effizienteres Modul (b) ersetzt werden.</p><formula xml:id="formula_22">T 3 T 3 v w VZ T 1 T 2 v w VZ T 1 T 2 T 5 T 4 T 5 T 4 (a) (b)</formula><p>Abbildung 7.6: Konstuktion einer Tour T aus einer Tour T unter der Annahme, dass T zweimal Knoten w direkt nach v besucht.</p><p>Beispiel fü einen solchen Austausch im Sinne der Effizienzsteigerung soll Abb. 7.5 dienen. Dort verlangt Modul 7.5a das Erreichen und sofortige Verlassen des Ganges von links oben, weshalb diese beiden Kanten und damit auch nicht notwendiger Weg eingespart werden kö.</p><p>Zu beachten ist außerdem, dass eine Tour, wie sie im Rahmen dieser Arbeit ver- standen wird, sich von Touren in Zusammenhang mit dem Travelling Salesman Pro- blem oder dem Vehicle Routing Problem unterscheidet. Die etwas andere Auffassung kommt daher, dass Knoten, wie zum Beispiel Kreuzungspunkte von Gä oder die Verdichtungszone, mehr als nur einmal besucht werden dü. Das ist notwendig, da meistens keine direkte Verbindung zwischen zwei Knoten des Lagergraphs besteht. Somit kö Pfade zwischen zwei Knoten mehrfach zurü werden, allerdings kann man die Anzahl an Verwendungen des selben Wegs von oben beschrä. Beweis. Angenommen der Weg zwischen v und w wird zweimal in der gleichen Rich- tung durchlaufen, dann kann man die Tour T in fü Teil-Touren T 1 , T 2 , T 3 , T 4 und T 5 aufteilen, wie in Abb. 7.6a zu sehen, wobei VZ fü die Verdichtungszone steht. Man kann nun eine neue Tour T erzeugen, welche beginnend bei VZ entlang von T 1 nach v verlä, dann T 3 von v nach w folgt, um schließlich T 5 folgend von w aus zu VZ zurü (siehe Abb. 7.6b). Da v und w adjazent sind, also kein anderer Punkt auf dem Weg von v nach w passiert werden muss, besucht T dieselben Punkte wie die Tour T . Weiters werden T 2 und T 4 innerhalb von T ausgelassen, wodurch T kü ist als T und das wiederum einen Widerspruch zu der Annahme darstellt,</p><formula xml:id="formula_23">(a) (b) (c) (d) (e) (f) (g)</formula><p>Abbildung 7.7: Sieben gü und potentiell verwendete Gangoperationen.</p><formula xml:id="formula_24">(a) (b) (c) (d) (e) (f) (g) (h) (i) (j) (k) (l) (m) (n) (o) (p)</formula><p>Abbildung 7.8: 16 gü und potentiell verwendete Zwischen-Gangoperationen.</p><p>dass T optimal ist. Rekursive Update Funktion Folgend aus den zuvor erwä Beobachtungen, sollen zwei (n + 1) × (ν) Matrizen σ und τ eingefü werden, wobei n die Anzahl an Gä mit einzusammelnden Artikeln und ν die Anzahl an verwendbaren Modulen sind. Ein Eintrag σ ij , mit 1 ≤ i ≤ n und 1 ≤ j ≤ ν, steht fü die Lä einer gü Tour T , welche alle Gä 1, . . . , i besucht, das heißt alle benö Artikel aus den Gä 1 bis i einsammelt und Modul j fü Gang i verwendet. Analog dazu steht ein Eintrag τ ij fü die Lä einer Tour T , welche wiederum die Gä 1, . . . , i besucht und Modul j fü Gang i verwendet. Im Gegensatz zu Tour T besteht aber bei Tour T die Mö durch Verwendung bestimmter Module in den Gä i + 1 bis n, ungü zu werden.</p><p>Die Einträ fü σ und τ berechnen sich mittels folgender rekursiver Funktion: σ 0µ = 0 (7.1) τ 0µ = 0 (7.2) σ 0j = ∞ fü j ∈ {1, . . . , ν} \ {µ} (7.3)</p><formula xml:id="formula_25">τ 0j = ∞ fü j ∈ {1, . . . , ν} \ {µ} (7.4) σ ij = c i (j) + min {σ i−1j : j ∈ M g (j)} ∪ {τ i−1j : j ∈ M g (j)</formula><p>} fü i ∈ {1, . . . , n} fü j ∈ {1, . . . , ν} (7.5)</p><formula xml:id="formula_26">τ ij = c i (j) + min {σ i−1j : j ∈ M komp (j)} ∪ {τ i−1j : j ∈ M komp (j)} fü i ∈ {1, . . . , n} fü j ∈ {1, . . . , ν} (7.6)</formula><p>In diesem Fall reprä Modul µ die Verdichtungszone. Wenn ein Modul j fü Gang i nur ungü Touren bilden oder nicht kompatibel nach unten sein wü, so wird σ ij = ∞, beziehungsweise τ ij = ∞ gesetzt.</p><p>Dekodierung einer optimalen Tour Sind nun die beiden Matrizen σ und τ wie beschrieben initialisiert worden, dann kann man die optimale Tour einfach daraus ableiten. Zuerst muss das Modul fü Gang n in der optimalen Tour gewä werden, welches jener Eintrag σ nj reprä, der minimal ist fü alle j. Um die bereits gemachten¨Uberlegungen zu ergä, sind alle gü Module in Gang n solche, die zwar mittels Zwischen-Gangoperationen zum Gang n − 1 verbinden, nicht aber zu Gang n + 1.</p><p>Zur Vereinfachung nehmen wir an dieser Stelle an, dass σ nJ das Modul fü Gang n in einer optimalen Tour bezeichnet. Es ist dann leicht zu zeigen, dass so ein Eintrag existieren muss. Nun kann man einfach innerhalb der Matrix zurü, dass das Modul fü Gang n − 1 jenes Modul j ist, fü das die Gleichung (7.7) erfü ist:</p><formula xml:id="formula_27">σ nJ − c i (j) = σ i−1j τ i−1j (7.7)</formula><p>Fü alle weiteren Gä lä sich die optimale Tour entsprechend ableiten. Sollte der Fall eintreten, dass mehr als ein Modul die Gleichung (7.7) erfü, so ist das gleichbedeutend damit, dass es mehrere optimale Touren gibt. Aus diesen Touren ist dann eine beliebige wä.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.3">S-Shape-Heuristik</head><p>Wie bereits in Kapitel 3.4 erwä, gibt es Arbeiten, welche zur Berechnung von Touren auf die so genannte S-Shape-Heuristik zurü. Das Verfahren folgt ei- nem einfachen Prinzip, wonach sich die Arbeiter auf S-fö Touren durch das 45 VZ Abbildung 7.10: Veranschaulichung der S-Shape-Heuristik</p><p>Lager bewegen. Dabei wird ein Gang durchquert sobald er betreten wurde. Natü werden Gä, aus denen kein Artikel geholt werden muss, ausgelassen. Zur Veran- schaulichung dieser Vorgehensweise soll Abb. 7.10 dienen. Laut den bereits referen- zierten Arbeiten <ref type="bibr" target="#b5">[4]</ref> sowie <ref type="bibr" target="#b6">[5]</ref> kann man auf diese Weise Lö finden, die fü viele Probleminstanzen nahe am Optimum liegen. Das ist der Grund dafü, weshalb diese Heuristik in Kombination mit TSH im Rahmen dieser Arbeit als Referenzver- fahren eingesetzt wurde. Damit kann man einen Vergleich zu den mittels des entwi- ckelten hybriden Verfahrens berechneten Ergebnissen anstellen und deren Qualitä einschä. Hierbei sollte darauf hingewiesen werden, dass es sich bei den mittels S- Shape-Heuristik gefundenen Werten nur um Richtwerte handelt. Im Gegensatz zum vorgestellten Algorithmus werden keine Nebenbedingungen geprü. Daher werden beispielsweise weder Kollisionen vermieden und Artikel stets vom ersten gefundenen Lagerplatz geholt anstatt nach alternativen Lagerplä zu suchen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Zuordnung von Arbeitern zu Touren</head><p>Zusä zu den bisherigen Schritten ist es noch wichtig eine Aufteilung aller be- rechneten Touren auf die verfü Lagerarbeiter zu erstellen. Das bedeutet, dass jedem Arbeiter eine Liste von Touren zugewiesen wird, die von diesem dann abgear- beitet werden muss. Nachdem sich aber alle Arbeiter gleichzeitig im Lager bewegen, mü entsprechende Maßnahmen getroffen werden, um gegenseitige Behinderungen auszuschließen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Zuordnung von Arbeitern zu Touren</head><p>Algorithmus 9 : Initiale Arbeiter-Zuordnung Input : eine Menge T von Touren T i , mit i = 1 . . . m; die Anzahl an Arbeitern</p><formula xml:id="formula_28">w Data : Menge W von Mengen W i , mit i = 1 . . . m, von abzuarbeitenden Touren, Zä l begin foreach W i ∈ W do W i ← ∅ ; j ← 1 ; foreach T i ∈ T do W j ← W j ∪ {T i } ; if l &lt; m then l ← l + 1 ; else l ← 1 ; return W ; end</formula><p>Eine Zuordnung von Arbeitern zu Touren soll also genau dann gü sein, wenn es zu keinem Zeitpunkt zu Kreuzungen der Touren zweier Arbeiter innerhalb von Re- galgä kommt. Des weiteren sind¨Uberholmanöver sind¨Uberholmanö in Gä nicht zulä. Um das berü zu kö, muss die Geschwindigkeit der Kommissionierungswa- gen genauso beachtet werden, wie auch die Zeit, die notwendig ist, um die jeweiligen Artikel auszufassen.</p><p>Trotz all dieser formalen¨Uberlegungen darf man nicht vergessen, dass immer noch Menschen in diesem Lager arbeiten, weshalb man entsprechende Zeitpuffer einplanen muss. Die Arbeitsgeschwindigkeit ist eben abhä von sehr vielen Faktoren, wie etwa Alter und Erfahrung der Arbeiter, oderäußerenoderä Einflü aus dem Umfeld des Lagers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.1">Konstruktionsheuristik</head><p>Zur Erzeugung einer Startlö fü weitere Berechnungen muss zunä eine in- itiale Zuordnung von Arbeitern zu Touren erfolgen, indem die vorhandenen Touren gleichmä auf alle Arbeiter verteilt werden. Der einfache Ansatz einer First-Fit Heuristik wird zum Auffinden einer solchen Initiallö herangezogen (siehe Alg. 9). Jedenfalls stellt eine solche erste Lö keinerlei Anspruch auf Korrektheit. Zum einen kö Kollisionen der Arbeiter innerhalb von Regalgä auftreten, zum anderen kann nicht garantiert werden, dass alle angeforderten Artikel innerhalb des zulä Zeitrahmens zur Verdichtungszone gebracht werden. Es mü also noch weitere Schritte folgen, um eine Zuordnung gü zu machen. Auch hier hilft wieder 47 die Umsetzung einer VNS weiter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4.2">Reparatur-und Verbesserungsheuristik</head><p>Zusä zur Entscheidung, ob eine Zuordnung von Arbeitern zu Touren gü ist, wird versucht eine Aufteilung zu finden, bei der alle Arbeiter mit ihren Arbeitsschrit- ten so frü wie mö fertig werden. Zu diesem Zweck bietet sich eine Zielfunktion an, die den letzten Endzeitpunkt aller Arbeiter auswertet. </p><formula xml:id="formula_29">WorkerShiftTourMove(i, j, k) Bei diesem Schritt wird Tour j, mit j ∈ W i , um k Positionen verschoben, wobei |k| &lt; |W i | und 1 ≤ j + k ≤ |W i |.</formula><p>Eine solche Umreihung kann in Bezug auf die termingerechte Abwicklung hilfreich sein.</p><p>WorkerSplitMove(i, R) Bei der Anwendung dieses Schrittes werden alle Elemente in R aus W i entfernt und in eine neue Zuordnung W i eingefü, welche dann einem neuen Arbeiter zugewiesen werden kann. Dieser Schritt kann natü nur angewendet werden, solange noch freie Arbeiter zur Verfü stehen.</p><p>Aus diesen Moves ergeben sich die Nachbarschaftsstrukturen WorkerSwap, WorkerS- hift, WorkerShiftTour und WorkerSplit.</p><p>Nachdem das Hauptziel dieser VNS Prozedur das Auffinden einer gü Zuordnung von Touren zu Arbeitern ist, werden nur Moves berü, deren Resultat eine gü Lö darstellt.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Erweiterter Algorithmus</head><p>Da die hier vorgeschlagenen Methoden insgesamt dafü ausgelegt sind in vergleich- bar kurzer Zeit relativ gute Lö zu erzeugen, ist es durchaus wahrscheinlich, dass die gefundenen Lö noch weiter verbessert werden kö. Zudem sind</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.5">Erweiterter Algorithmus</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithmus 10 : Erweiterter Algorithmus</head><p>Input : Bestellungen mit Listen aller einzusammelnder Artikel Output : Eine Zuordnung von Arbeitern zu fertigen Touren begin repeat</p><formula xml:id="formula_30">(1)</formula><p>Erstelle Partitionierung vorhandener Bestellungen ; repeat repeat <ref type="bibr" target="#b3">(2)</ref> Berechne Zuordnung von Artikeln zu Touren ;</p><p>Berechne optimale Touren fü die oben erstellte Zuordnung ; until keine Verbesserung konnte erzielt werden ; <ref type="bibr" target="#b5">(4)</ref> Erstelle eine Zuordnung von Arbeitern zu Touren ; return die aktuelle Zuordnung von Arbeitern zu Touren ; until ein definiertes Abbruchkriterium ist erfü ; until keine weiteren Bestellungen sind abzuarbeiten ; end zu dem Zeitpunkt, zu dem der Algorithmus zu arbeiten beginnt, noch nicht alle Bestellungen bekannt, die im Laufe des Tages zu bearbeiten sein werden. Deshalb empfiehlt es sich eine erweiterte Variante des Alg. 3 wie in Alg. 10 beschrieben zu verwenden. Anstelle eines Abbruchs, sobald eine Zuordnung von Touren zu Arbeitern gefunden wurde, soll der Algorithmus hier wieder von vorne beginnen, allerdings un- ter Berü von bereits bearbeiteten Aufteilungen. Das bedeutet etwa, dass bereits eingesammelte Artikel natü nicht mehr vertauscht werden kö, oder, dass Arbeiter, die bereits auf dem Weg zu einem Artikel sind nicht mehr anders geschickt werden kö. Sonstigë Anderungen kö natü noch durchgefü werden, solange sie eine Verbesserung der Gesamtlö bringen. Der Algorithmus sollte dann arbeiten, bis alle Bestellungen anforderungsgemä bearbeitet wurden.</p><p>Um den Algorithmus mö effizient zu gestalten, mü natü auch die dar- unterliegenden Datenstrukturen entsprechend gewä werden und Bewertungsfunk- tionen oder im Speziellen die Funktion zur Berechnung optimaler Touren mö schnell arbeiten. <ref type="bibr">49</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Testergebnisse</head><p>Um die Verwendbarkeit der vorgestellten Methode im industriellen Umfeld abschä- zen zu kö, wurden zahlreiche Testlä durchgefü. Als Hardware wurde ein zur Zeit aktuelles Arbeitsplatzsystem gewä -konkret ein Dual Xeon mit 2.6 GHz und 8 GB RAM. Leider war es nicht mö Echtdaten zu bekommen, da zum Zeitpunkt der Fertigstellung dieser Diplomarbeit noch keine hardwaremä Reali- sierung im Ersatzteillager unseres Industriepartners vorgenommen wurde, weswegen auf statistische Parameter, die im Laufe des vergangenen Jahres gesammelt wur- den, zurü werden musste, um zufä Testinstanzen zu generieren. Hierzu wurde das Lager modelliert und die einzusammelnden Artikel den Parametern ent- sprechend zufä im Lager verteilt. Zusä wurden typische Kundenbestellungen erzeugt. Variable Parameter waren dabei die Summe der insgesamt bestellten Arti- kel und die Anzahl der Kundenbestellungen. Nach Rü mit den Lagerleitern wurde festgesetzt, dass Rechenzeiten bis 20 Minuten als akzeptabel gelten, weswegen die maximal verfü Rechenzeit auf diese 20 Minuten gesetzt wurde.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Wahl der Konstruktionsheuristik</head><p>In einem ersten Vortest wurde untersucht wie die beiden Konstruktionsheuristiken zur Findung einer Ausgangslö den gesamten Algorithmus beeinflussen. Die ver- wendeten Testinstanzen sind nicht ident mit jenen der spä Testlä, da durch die im Laufe der Entwicklung entstandenen Erweiterungen des Programms auch die Testdatenüberarbeitet Testdatenü werden mussten. Deshalb sind die Ergebnisse dieses Vortests nicht direkt mit den spä vergleichbar. In Tab. 8.1 sind die gesammelten Ergeb- nisse ersichtlich. Sie zeigen die absoluten Werte der Summe aller Tourlä fü die in Kapitel 7.2.1 vorgestellten Konstruktionsheuristiken CAH und TSH.</p><p>Natü sind diese Werte fü sich noch nicht sehr aussagekrä, vergleicht man sie allerdings miteinander, so lassen sich gewisse Beobachtungen machen. Zunä fä auf, dass die errechneten Werte der Tourlä nicht in unmittelbarem Zu- sammenhang mit der gewä Methode zur Erzeugung einer Startlö gebracht werden kö. Es gibt in beiden Fä an manchen Stellenüberdurchschnittlich Stellenü große Abweichungen. Abgesehen von wenigen Ausnahmen schwanken die Werte fü die Tourlä im direkten Vergleich zwischen den beiden Konstruktionsheuristiken kaum. Das legt die Vermutung nahe, dass die Wahl der Konstruktionsheuristik, wennüberhaupt wennü, nur einen vernachlä Einfluss auf die endgü Lö hat. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Wahl von Berechnungsparametern</head><p>Der erste durchgefü Testlauf sollte nun zeigen, wie sich gewisse Berechnungspa- rameter auf den Algorithmus auswirken. Zwei wesentliche Steuerungsmö sind zum einen das Erlauben oder Verbieten des Umkehrens innerhalb von Gä, was bedeutet, dass ein Gang komplett durchquert werden muss, falls er betreten wird. Zum anderen ist das die Verwendung von statischen oder dynamischen Rei- henfolgen fü die Nachbarschaften der VNS. Wie bereits in Kapitel 7.2.4 beschrieben wurde, erfolgt bei dynamischer Nachbarschaftsreihenfolge laufend eine Umreihung dieser Strukturen, um Lö durch normalerweise spä durch- suchte Nachbarschaften, die dann mö gar keine Verbesserungen erzielen, schon frü zu ermö. In Tab. 8.2 (ohne Artikel auf alternativen Lagerplä) und Tab. 8.3 (mit Artikeln auf alternativen Lagerplä) sind die gesammelten Ergebnisse des Testlaufs (Testlauf 1) zusammengefasst. Dabei wird die mittels S- Shape-Heuristik (siehe Kapitel 7.3.3) gefundene Lö als Referenz herangezogen. Die berechneten Werte werden dann prozentuell dazu angegeben, sodass ein direk- ter Vergleich mö ist. Da alle Werte den Durchschnittüber Durchschnittü 20 Durchlä re- prä, wird auch die Standardabweichung angefü. Zu beachten ist hierbei, dass die mittels S-Shape-Heuristik erzielten Werte nur als Anhaltspunkt dienen und keinerlei Nebenbedingungen berü wurden. Zusä sind noch die Durch- schnittswerte fü Laufzeit und Kapazitä der Kommissionierungswagen angegeben. Verwendet wurden die Nachbarschaften Split, Merge, Shift, Swap, Swap- Position, SwapPositionMerge, SplitPositionMerge und DoubleShift. Diese Auflistung entspricht gleichzeitig der Anfangsreihenfolge der Nachbarschaften.</p><p>Man kann nun beim Untersuchen der Tabellen einige interessante Entdeckungen ma- chen. Zunä mö ich auf den Vergleich von statischer und dynamischer Nach- barschaftsreihenfolge eingehen. Hier ist bei den kleinen Instanzen mit 25 Artikeln zu sehen, dass die Werte der Zielfunktionen sehr nahe beisammen liegen, bei dynami- scher Nachbarschaftsreihenfolge dennoch leicht bessere Werte vorliegen. Die Laufzeit ist allerdings geringfü lä, wenn auch nicht sehr viel. Interessant hingegen sind die Instanzen mit 50 Artikeln, bei denen sowohl ein besseres Laufzeitverhalten, als auch ein besserer Zielfunktionswert zu bemerken ist, wenn dynamische Nachbar- schaftsreihenfolge verwendet wird. Auch bei jenen Instanzen mit 100 Artikeln bringt die Berechnung mittels dynamischer Nachbarschaftsreihenfolge stets ein besseres Er- gebnis in beiden Bereichen. Fü die grö Instanzen mit 200 Artikeln wiederum muss man sagen, dass die dynamische Reihenfolge der Nachbarschaften keinen klaren Vorteil bringt. Das mag aber mö daran liegen, dass bei so vielen Arti- keln große Teile des Lagers durchlaufen werden mü, also kaum Wege eingespart werden kö und somit die Optimierung weniger Optionen zur Verfü hat. Außerdem werden nach der gegebenen zeitlichen Beschrä die Berechnungen unterbrochen. Um die Auslastung der Kommissionierungswagen nicht außer Acht zu lassen, sei erwä, dass die Durchschnittswerte eine durchwegs hohe Belegung zei- gen, was deutlich fü die Effizienz der Berechnungen spricht. Gesamt betrachtet lä 53 Nun zum Unterschied zwischen den Werten mit und denen ohne Umkehren. Vor al- lem bei kleineren bis mittleren Instanzen sind klare Vorteile durch das Zulassen des Umkehrens auszumachen. Auch hier sind interessanter Weise die Laufzeiten leichtüber leichtü denen der Tests ohne Umkehren. Sobald die Instanzen eine Grö erreichen, bei der der Algorithmus abgebrochen wird, lä sich nur schwer eine Aussage darü machen, wie reprä die Werte sind. Aber wie auch beim Vergleich zwischen statischer und dynamischer Nachbarschaftsreihenfolge sind keine klaren Vorteile fü ein Verfahren auszumachen. Dennoch scheint man mit Umkehren eher bessere Er- gebnisse erzielen zu kö.</p><p>Weiters wurden die Instanzen hinsichtlich ihrer Lö bei Verwendung von al- ternativen Lagerplä fü bestimmte Artikel untersucht. Das heißt also, dass man- che Artikel an mehreren Positionen im Lager verfü sind und damit zusä Mö zur Bildung von Touren vorliegen kö. Wirklich klare Unterschiede sind hier nur schwer zu erkennen. Wennüberhaupt Wennü, so sind am ehesten in Kombina- tion mit dem Erlauben des Umkehrens leichte Vorteile auszumachen. Das liegt aber sicherlich auch daran, dass nicht alle Artikel an mehreren Positionen verfü sind. Somit kann es auch passieren, dass fü die angeforderten Artikel keine alternativen Lagerplä existieren und somit dieselbe Problemstellung vorherrscht wie bei der Berechnung ohne alternative Lagerplä.</p><p>Generell sind nach diesen Tests natü nur Tendenzen auszumachen, es ist aber zu beachten, dass durchaus die Werte fü kleinere Instanzen ausschlaggebend sind, da, wie auch schon in der Problembeschreibung erwä, nicht alle angeforderten Artikel auf einmal bekannt sind. Es kann also angenommen werden, dass im Ver- lauf eines Arbeitstages immer wieder kleinere Instanzen verarbeitet werden. Unter diesem Gesichtspunkt bieten die zuvor gefundenen Unterschiede durchaus eine Ent- scheidungsgrundlage zur Wahl entsprechender Berechnungsparameter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Effizienz einzelner Nachbarschaften</head><p>Neben den im vorigen Abschnitt erlä Ergebnissen, wurde auch das Verhal- ten der Nachbarschaften im Verlauf des Algorithmus ausgewertet. In Tab. 8.4 ist zu sehen wie hoch der Anteil an Verbesserungen gegenü allen getesteten Schrit- ten einer Nachbarschaft ist. Wurden also beispielsweise 100 Schritte innerhalb einer Nachbarschaft getestet und fü 80 davon zu einer Verbesserung, so wü in der Tabelle ein Wert von 80% vermerkt werden. Die ersten vier Nachbarschaften stellen grundlegende Operationen zur Lö dar, weshalb sie auch zu Beginn gereiht werden. SplitMove ist an erster Stelle, um aus anfä meist großen Touren zunä mehrere kleinere zu erzeugen. Die Laufzeiten der folgenden Nachbarschaf-ten ShiftMove und SwapMove sind abhä von der Anzahl der Touren insgesamt, weshalb vor diesen beiden noch Merge durchsucht wird. Das ermö das Zusam- menfü mancher Touren, falls dies eine Verbesserung bringt. Erst im Anschluss an diese vier Nachbarschaften folgen jene, deren Komplexitä grö ist, wobei die Reihenfolge hier auf Basis von kleineren Vortests so gewä wurde. Es folgen also noch SwapPosition, SwapPositionMerge, SplitPositionMerge und DoubleShift. Selbst- verstä wirkt sich diese Reihenfolge nur direkt bei Verwendung von statischer Nachbarschaftsreihenfolge aus. Das Durchsuchen der Nachbarschaften erfolgte außer- dem unter Verwendung der Strategie Next Improvement (siehe dazu auch Kapitel 5).</p><p>Sofort fallen viele Einträ mit " 0.0%" auf. Vor allem Nachbarschaft N 7 ist hier sehr dominant, was aber durchaus zu erklä ist, da ein verteiltes Einsammeln eines Ar- tikels von mehreren Positionen bedeutet, eine Position mehr im Lager anfahren zu mü. Es ist zwar vorstellbar, dass in manchen Szenarien solch eine Aufteilung von Nutzen ist, die Tests haben allerdings gezeigt, dass damit nicht sehr viel verbes- sert werden kann. Das Verhalten im Echtbetrieb kann leider nur schwer eingeschä werden, denn hierzu mü man auf Basis von echten Daten entsprechende Aus- wertungen erstellen. Weiters sind die Nachbarschaften N 5 und N 6 nur dann sinnvoll, wenn auch alternative Positionen von Artikeln im Lager verwendet werden, deshalb wurden die entsprechenden Einträ mit " -" markiert. Zusä dazu beeinflusst die dynamische Reihung der Nachbarschaften deren Effizienz entscheidend, was sehr deutlich bei N 8 zu sehen ist. Da bei statischer Reihenfolge der Nachbarschaften schon N 3 viele ShiftMoves durchfü, so bleiben fü N 8 natü kaum mehr Mö- ten zur Verbesserung. Anders bei dynamischer Reihenfolge, wo die Nachbarschaften einigermaßen gleichmä verteilt zum Einsatz kommen. Eine weitere Beobachtung kann hinsichtlich N 2 gemacht werden. Der Prozentsatz ist hier vor allem bei grö Instanzen sehr klein, was darauf zurückzufü ist, dass Merge nur dann sinnvoll verwendet werden kann, wenn Kommissionierungswagen weit unter ihrer Kapazitä ausgelastet sind, was lediglich zu Beginn des Algorithmus sehr wichtig ist, mit zu- nehmender Laufzeit aber kaum mehr vorkommen dü. Besonders effizient hinge- gen verhä sich N 1 , wo ein sehr hoher Prozentsatz an erzeugten SplitMoves auch tatsä zu einer Verbesserung der Gesamtlö fü. Dabei steht vor allem das Beseitigen vonüberfüllten vonüberfü Kommissionierungswagen und damit ungü Touren im Vordergrund.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Rechenzeit der Nachbarschaften</head><p>Reprä fü das Laufzeitverhalten der einzelnen Nachbarschaften soll Tab. 8.5 (Testlauf 1) zeigen, wie hoch der Rechenaufwand der einzelnen Nachbarschaften ausfä.</p><p>Vor allem N 8 schlä hier mit besonders hohem Aufwand zu Buche, was durch die ei- nigermaßen hohe Effizienz bei Verwendung dynamisch verä Nachbarschafts- 57         </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Rechenzeit der Nachbarschaften</head><p>Tabelle 8.5: Rechenzeit -Durchschnittswertë uber 20 Testlä mit 25, 50, 100 und 200 einzusam- melnden Artikeln. Zu sehen ist der prozentuelle Anteil (alle Werte in Prozent <ref type="bibr">[%]</ref>) an Rechenzeit der jeweiligen Nachbarschaft in Relation zur Rechenzeit fü alle Nachbarschaften fü Instanzen oh- ne bzw. mit Artikeln auf alternativen Lagerplä bei Berechnung mit Umkehren innerhalb eines Ganges und dynamischer Nachbarschaftsreihenfolge.</p><p>(N 1 : Split; N 2 : Merge; N 3 : Shift; N 4 : Swap; N 5 : SwapPosition; N 6 : SwapPositionMerge; N 7 : SplitPositionMerge; N 8 : DoubleShift; N 9 : ShiftSplit; N 10 : SwapSplit; N 11 : MultipleSwap; N 12 : MultipleSplit; N 13 : SplitMerge.)  strukturen durchaus vertretbar ist. Bei statischer Nachbarschaftsreihenfolge hingegen macht die Verwendung dieser Nachbarschaft keinen Sinn und sollte ausgelassen wer- den. Wie intuitiv außerdem zu erwarten war, benö N 3 und N 4 deutlich mehr Aufwand zum Durchsuchen, als dië ubrigen Nachbarschaften. Sind es bei kleinen In- stanzen noch je etwa 10% der Rechenzeiten, so steigt der Anteil fü große Instanzen auf 30-40% an.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Laufzeit und Lö</head><p>Ein wesentlicher Aspekt des entwickelten Algorithmus ist das Auffinden von guten Lö innerhalb mö kurzer Zeit, da im Echtbetrieb nicht uneingeschrä viel Zeit zur Verfü stehen kann. Aus diesem Grund ist eine Visualisierung des Verlaufs der Lö durchaus interessant, was anhand von Instanz M3 bei Berechnung mit alternativen Lagerplä und dynamischer Nachbarschaftsrei- henfolge in Abb. 8.1 dargestellt wird. Es ist dabei eindeutig zu erkennen, dass in- nerhalb der ersten 100 Iterationen des VND bereits eine sehr gute Lö erreicht wird, welche im weiteren Verlauf zwar noch geringfü verbessert wird, aber nicht mehr in so hohem Maß wie zu Beginn. Es sollte darauf hingewiesen werden, dass die Verbesserungen innerhalb der zweiten 100 Iterationen bei weitem nicht so gravierend sind, da hier die verä Skalierung der y-Achse fü die Tourlä zwischen 0 und 50000 beachtet werden muss.</p><p>Dieses Verhalten istäußerstistä gü fü die Verwendung im realen Umfeld, wo vor allem schnelle Antwortzeiten von Bedeutung sind. In manchen Fä wird es dort nö sein, schon nach kurzer Zeit den Algorithmus abzubrechen und die bis dahin vorliegende Lö zu verwenden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Lösungsqualitä bei Verwendung zusä Nachbarschaften</head><p>Um das Verhalten des Algorithmus bei der Verwendung zusä Nachbarschaften beobachten zu kö, wurde ein weiterer Testlauf durchgefü, der unter den glei- chen Voraussetzungen wie der in Kapitel 8.2 beschriebene durchgefü wurde. Hier- bei wurde allerdings nur mehr mit dynamischer Nachbarschaftsreihenfolge gerechnet, es kamen aber weitere Nachbarschaften zum Einsatz. Verwendet wurden hier neben Split, Merge, Shift, Swap, SwapPositionMerge, SplitPositionMerge und DoubleShift auch ShiftSplit, SwapSplit, MultipleSwap, MultipleSplit und SplitMerge. Diese Auf- listung entspricht wieder gleichzeitig der Anfangsreihenfolge der Nachbarschaften. Weiters wurde SwapPosition ausgelassen, da diese bereits durch SwapPositionMerge abgedeckt ist. In Tab. 8.2 und Tab. 8.3 sind die in diesem Test (Testlauf 2) erzielten Ergebnisse und Laufzeiten des Algorithmus zu sehen. Diese Tabellen enthalten auch die Ergebnisse aus Testlauf 1, was die Gegenü erleichtert. Es ist zu erkennen, dass von allen berechneten 80 Instanzen nur 11 nicht besser gelö werden konnten und die Summe aller Zielfunktionswerte bei Instanzen ohne Umkehren innerhalb von Gä um rund 20% und bei Instanzen mit Umkehren sogar um etwa 22% verbessert wer- den konnte. Gleichzeitig muss aber auch gesagt werden, dass die Berechnungen zum Teil mehr als die doppelte Laufzeit bei kleineren Instanzen benö. Dennoch konnten auch die Zielfunktionswerte großer Instanzen, deren Bearbeitung nach dem Grenzwert von 1200 Sekunden abgebrochen wurde, in derselben Zeit wie im vorigen Testlauf deutlich verbessert werden.</p><p>Die Auswertung der Effizienz der Nachbarschaften in Tab. 8.6 zeigt einähnlicheseinä Bild, wie in Tab. 8.4. Zur besseren¨Ubersicht wurden nur die Werte fü Berechnungen mit Umkehren innerhalb eines Ganges herangezogen. Zusä ist hier ersichtlich, dass die neu hinzugekommenen Nachbarschaften N 9 -N 13 eine durchwegs hohe Verbesse- rungsquote aufweisen.</p><p>Die Rechenzeiten aus Testlauf 2, wie in Tab. 8.5 zu sehen ist, weisen Parallelen zu den in Testlauf 1 erhaltenen Werten auf. Im Wesentlichen bestä das Ergebnis die be- reits zuvor ermittelten Zahlen, wobei es zu leichten Verschiebungen gekommen ist, da die neu hinzugefü Strukturen mit Kombinationen aus zuvor einzeln angewandten arbeiten. Hier sind die Berechnungen fü kombinierte und damit komplexere Struk- turen natü auch aufwä, aufgrund des Erfolgs ist deren Anwendung aber wü. Besonders auffä ist der hohe Rechenaufwand fü SplitMergeCom- bine, wo im Vergleich dazu im vorangegangenen Testlauf DoubleShift den grö Anteil an Rechenzeit benö.</p><p>Es hat sich also gezeigt, dass die neu eingebundenen Nachbarschaftsstrukturen ein durchwegs positives Resultat bringen und die Lö tatsä verbessern konnten. Teilweise konnten die Zielfunktionswerte sogar um 50% verringert werden und nur in wenigen Fä wurden geringfü schlechtere Ergebnisse erzielt, als beim vorherigen Testlauf.</p><p>Abschließend ist zu den Testergebnissen zu sagen, dass durchwegs positive Resultate erzielt werden konnten. Auch im Vergleich zur Lö mittels S-Shape-Heuristik konnten mehrheitlich bessere Werte berechnet werden. Zusä dazu sollte noch einmal darauf hingewiesen werden, dass unter der Verwendung der S-Shape-Heuristik keine Nebenbedingungen, wie etwa Kollisionen zwischen Arbeitern, geprü werden konnten. Es wurde damit lediglich eine Referenzlö erzeugt.</p><p>Es bleibt nun noch zu erwä, dass die hiermit geschilderten Beobachtungen darauf schließen lassen, dass weitere Verbesserungen etwa in Zusammenhang mit Anpassun- gen der Nachbarschaftsstrukturen durchaus mö sind. In jedem Fall bietet sich ein Einsatz im Echtbetrieb an, um die Leistungsfä des entwickelten Ansatzes unter realen Bedingungen zu ermitteln.</p><p>Verspä eines Arbeiters auf seiner Tour, etc.) aussagekrä zu testen, da auf- grund des erst neu eingefü Verwaltungssystems die Testdaten nicht dem Echt- betrieb entnommen werden konnten. Daher musste versucht werden, beim Gene- rieren der Testdaten alle bekannten Aspekte und Eigenschaften der Lagerstruktur bestmö zu berü.</p><p>Anzumerken ist noch, dass die Methode zum Berechnen von optimalen Kommis- sionierungstouren teilweise auf der Annahme basiert, dass ein Mitarbeiter in einem Gang jederzeit umdrehen kann. Je nach Beschaffenheit des Lagers und der verwen- deten Fahrzeuge kann es durchaus vorkommen, dass eine solche Richtungsä nicht, beziehungsweise nur schwer mö ist. Sollte dies der Fall sein, kann das Dynamische Programm einfach angepasst werden. Die grundlegende Struktur des AnsatzesändertAnsatzesä sich dadurch nicht.</p><p>Im Rahmen der Tests hat sich gezeigt, dass die gefundenen Lö im Vergleich zu ebenfalls berechneten Referenzlö von guter Qualitä sind und zusä dazu alle Nebenbedingungen erfü werden konnten. Aber auch die Laufzeit des Verfahrens und vor allem die raschen Verbesserungen zu Beginn eines Durchlaufs vermitteln einen positiven Eindruck.</p><p>In Hinblick auf eine Beschleunigung des Algorithmus gä es die Mö auf die Berechnung exakter Touren zu verzichten. Natü wü man in diesem Fall zwar Geschwindigkeit gewinnen kö, mü aber bei der Lösungsqualitä Einbu- ßen hinnehmen. Auch ein nochmaliges¨Uberarbeiten der Nachbarschaftsstrukturen kö die eine oder andere Verbesserung bringen. Es sollte aber erwä werden, dass der prä Ansatz bereits mit stabilem Verhalten und vielversprechender Leistungüberzeugen Leistungü kann.</p><p>Als Fazit lä sich sagen, dass der Einsatz eines computerunterstü Entschei- dungssystems zur Planung von Kommissionierungstouren durchaus sinnvoll scheint, wenngleich aufgrund der Problemkomplexitä auf eine besonders effiziente Imple- mentierung geachtet werden muss. Besonders berü werden muss dabei die Tatsache, dass dies ein System sein soll, dass darauf abzielt Menschen in gewisser Hinsicht Befehle zu erteilen, was einerseits soziale Schwierigkeiten mit sich bringt und andererseits aber auch bedeutet, dass Zustä erreicht werden kö, die im Vorhinein nur schwer vorherzusehen sind. Das System sollte also nur als Entschei- dungsunterstü eingesetzt werden und kann die Kontrolle und Betreuung durch einen qualifizierten Lagerarbeiter nicht ersetzen.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>:</head><label></label><figDesc>Abbildung 5.1: Lokale Optima und globales Optimum im Verlauf der Zielfunktion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>21 22 Die vorliegende Problemstellung macht es unmö ein konstruktives Verfahren zu entwickeln, dass in polynomieller Zeit zur optimalen Lö fü, weshalb eine Alter- native gefunden werden muss. Die Herausforderung dabei stellen die Probleminstan- zen dar, durch welche bei einer Grö, die im Echtbetrieb vorstellbar wä, die Anzahl der gü Lö sehr groß wird. Wü man alle mö Lö- gen untersuchen wollen oder mit exakten Verfahren wie Branch &amp; Bound arbeiten, so wü dies zu nicht akzeptablen Rechenzeiten fü. Man kann davon ausgehen, dass es sich dabei um mehrere Stunden handeln wü, man im Echtbetrieb je nach Situation aber bei einer vertretbaren Zeitspanne im Bereich von Sekunden bis zu maximal wenigen Minuten liegen muss.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>:</head><label></label><figDesc>Abbildung 7.1: Lagerreprä (a) als Graph (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>:</head><label></label><figDesc>Abbildung 7.4: Gü und ungü Module.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Gegeben ist eine Tour T von kü Lä in Bezug auf eine Menge an Punkten, die von T besucht werden. Weiters wird angenommen, es gibt zwei adjazente Punkte v und w, welche in T zweimal unmittelbar hintereinander besucht werden. Der Weg zwischen v und w wird dann in T einmal von v nach w passiert und einmal umgekehrt.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fü</head><label></label><figDesc>ein sinnvolles VNS Verfahren muss nun noch eine Anzahl an Nachbarschaften (hier anhand von Moves) definiert werden. Sei W = w i=1 {W i } die Menge aller Zu- ordnungen W i von Arbeitern zu Touren. Weiters nehme man an, dass T = m i=1 {T i } die Menge aller zuvor berechneter Touren beschreibt. Folgende Moves bilden die Basis fü die verwendeten Nachbarschaften: WorkerSwapMove(i, j, k, l) Dieser Schritt definiert einfach den Austausch von Tour k ∈ W i und l ∈ W j , mit 1 ≤ i &lt; j ≤ m und k = l. Das bedeutet schlicht, dass zwischen zwei Arbeitern je eine Tour ausgetauscht wird. WorkerShiftMove(i, j, k) Hier wird lediglich eine Tour k ∈ W i aus W i entfernt und in W j an letzter Stelle angefü, wobei 1 ≤ i, j ≤ m und i = j. Das kommt einem Verschieben einer Tour von einem Arbeiter zu einem anderen gleich.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>Testlä mit 25, 50, 100 und 200 einzusammelnden Artikeln (Ar</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>Abbildung 8.1: Verlauf der Zielfunktion im Vergleich zur Anzahl der gefundenen Verbesserungen (Achtung: Unterschiedliche Skalierung der y-Achse fü [0; 50000] und (50000; 2000000])</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>licher Beitrag dazu ist ein von mir im Rahmen dieser Arbeit erstelltes Programm, das der Umsetzung sä innerhalb einer Heuristik dient. Dabei wird die vorhandene Problemstellung in vier algorithmischen Schritten bearbeitet. Es wird anhand bestimmter Kriterien, wie etwa Lieferzeit oder Platzbedarf eines Artikels, bestimmt, welche Artikel innerhalb einer Tour eines Arbeiters im Lager eingesammelt werden sollen. Der Schritt zur Berechnung von Touren ist dabei ein zentraler Bestandteil des Algorithmus und wurde mittels eines speziell entwickelten Dynamischen Programms umgesetzt. Sobald alle benö Touren berechnet wur- den, kö diese auf alle verfü Lagermitarbeiter aufgeteilt werden, was im letzten Schritt erfolgt.</figDesc><table>Regal 
Regalgang 
Hauptgang 

VZ Verdichtungszone 

VZ 

Abbildung 1.1: Schematische Darstellung des Lagers 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>4 .</head><label>4</label><figDesc></figDesc><table>Der Mitarbeiter in der Verdichtungszone verfä weiterhin so, dass er alle 
Artikel eines Auftrags in entsprechende Schachteln verpackt und an den Bo-
tendienstübergibt tendienstü. Dabei muss er allerdings beachten, dass nun die Artikel, die 
einer Bestellung zugeordnet sind, auf unterschiedlichen Kommissionierungswa-
gen zwischengelagert sein kö. 

Die Verdichtungszone selbst (siehe Abb. 2.1) ist in drei Zonen unterteilt, die als eine 
Art Zwischenlager verstanden werden kö. Von dort holen die Lagermitarbeiter 
leere Kommissionierungswagen, um Artikel aus dem Lager auszufassen und stellen 
diese befü wieder dort ab. Mitarbeiter, die fü Verpackung und Versand zustä 
sind, kö dann von dort die entsprechenden Waren abholen und die Bestellabwick-
lung fortsetzen. Da diese einzelnen Zonen entsprechend weitlä sind, um genü 
Platz zu bieten, ist vorgesehen, dass alle zu einer Bestellung gehö Artikel inner-
halb derselben Zone abgeliefert werden sollen. Dies verringert den Zeitaufwand fü 
die Verpackung und macht die Arbeit in der Verdichtungszone wesentlich einfacher 
und effizienter. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Generalized Traveling Salesman Problem [10] behandelt die leicht abgeä Variante des eigentlichen Problems, welche alle zu besuchenden Orte in Gruppen einteilt und verlangt, dass genau ein Ort aus jeder Gruppe besucht werden muss. Welcher das ist, kann frei gewä werden. Es sind dafü also zwei miteinander ver</head><label></label><figDesc></figDesc><table>-
knü große Schritte notwendig, nä einerseits die Auswahl einer Teilmenge von 
Knoten des zugrunde liegenden Graphen, wobei aus jeder Gruppe von Orten jeweils 
genau einer in dieser Teilmenge enthalten ist und andererseits die Bestimmung einer 
Tour mit minimalen Kosten innerhalb des Teilgraphen, der aus den ausgewä 
Knoten entstanden ist. 

3.4 Bekannte Lösungsansä 

Zur Lö des Vehicle Routing Problem gibt es einige Ansä, die unter anderem 
Variable Nachbarschaftssuche oder Tabu-Suche einsetzen. Hierbei wird der Einsatz 
solcher heuristischer Verfahren gewä, da aufgrund der Problemstellung bereits fü 
kleine Probleminstanzen eine Vielzahl an mö Lö existiert, gleichzeitig 
aber kein Algorithmus bekannt ist, der in polynomieller Zeit eine optimale Lö 
konstruiert. 

In [13] wird etwa beschrieben, wie mittels Tabu-Suche nach einer Lö fü ein 
SDVRP kombiniert mit einem VRPTW gesucht werden kann, fü die die Anzahl 
der verwendeten Fahrzeuge sowie die Lä der insgesamt zurü Strecke 
minimiert werden. 

Auch exakte Verfahren wie Ganzzahlige Lineare Optimierung (engl.: Integer Linear 
Programming) (ILP) und Branch &amp; Bound beziehungsweise Branch &amp; Cut werden 
hä zur Lö herangezogen. Ausgehend von einer ILP-Formulierung beschreibt 
etwa [15] einen solchen Ansatz zur Lö von CVRP-Instanzen mittels Branch &amp; 
Cut. 

In Zusammenhang mit Warenlagern, deren Anordnung in klassischer rechteckiger 
Form vorliegt, ist auch das Aufsuchen von Touren ein interessantes Teilproblem im 
Zuge der Optimierung von Lagerablä. In [5] wird ein Verfahren, die sogenannte 
S-Shape-Heuristik, betrachtet, das der Erstellung solcher Touren dient. Dabei be-
wegen sich die Lagerarbeiter S-fö durch das Lager, das heißt, dass ein Gang 
komplett durchquert wird, sobald er einmal betreten wurde. Interessant ist dieser 
Ansatz besonders deshalb, da er spä fü Vergleiche zu dem in dieser Arbeit vor-
gestellten Verfahren herangezogen wird. Betrachtungen der S-Shape-Heuristik, sowie 
Varianten davon finden sich auch in [4], wo außerdem auf die Komplexitä solcher La-
gerablä hingewiesen wird und klar hervorgeht, dass entsprechende Probleme stets 
sehr speziell sind. Es gibt also kein Konzept und kein globales Optimierungsmodell 
fü eine systematische BehandlungähnlicherBehandlungä Situationen. 

13 

14 Unter dem Begriff der Dynamischen Programmierung versteht man ein algorithmi-
sches Verfahren, bei dem in mehreren voneinander abhä Schritten Entschei-
dungen getroffen werden, die zur optimalen Lö eines Problems fü. Dabei ist 
stets die Lö eines Problems unter Ausnü des Wissensüber Wissensü bereits gelö 
Teilprobleme ein wesentlicher Bestandteil. Die in den einzelnen Berechnungsschrit-
ten zu lö Teilprobleme sind außerdem immer abhä von den zuvor schon 
gelö. Sobald zu einem Teilproblem eine Lö berechnet wurde, wird diese mit-
protokolliert, um fü die spä Verwendung abgerufen werden zu kö und nicht 
wiederholt berechnet werden zu mü. So arbeitet man sich schrittweise anhand 
optimaler Teillö zur Lö des Gesamtproblems vor. 

Der Ansatz der Dynamischen Programmierung basiert auf folgendem ursprü 
von Bellman formulierten Postulat [3]: 

" 
Ein optimales Verfahren hat die Eigenschaft, dass, wie auch immer 
der Anfangszustand und die erste Entscheidung ausfielen, die folgenden 
Entscheidungen fü eine optimale Lö sich auf den Zustand, der aus 
der ersten Entscheidung resultiert, beziehen mü." 

Wesentlich dabei ist, dass alle Entscheidungen des Algorithmus von bereits zuvor 
getroffenen abhä. Das bedeutet, dass die Lö eines Teilproblems als Aus-
gangspunkt stets die Lö eines vorangehenden Teilproblems heranziehen muss. 
Folgt man diesem Prinzip, dann versucht man das Problem derart zu zerlegen, dass 
jedes der entstehenden Teilprobleme optimal gelö werden kann. Am Ende wird die 
optimale Lö des initial formulierten Problems erreicht und kann durch die zuvor 
durchgefü Schritte zusammengesetzt werden. 

EinähnlicherEinä Ansatz, der ebenso das Zerlegen eines Problems in Teilprobleme ver-
folgt, ist Divide &amp; Conquer. Dieses Verfahren unterscheidet sich allerdings wesentlich 
von Dynamischer Programmierung, da hier per Definition keine Abhä zwi-
schen den einzelnen Teilproblemen bestehen muss. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>1 .</head><label>1</label><figDesc></figDesc><table>Aufteilung des Problems in kleinere, voneinander abhä Probleme 

2. Finden einer optimalen Lö fü die Teilprobleme 

3. Kombinieren der optimalen Teillö zur Berechnung der optimalen Lö 
fü das Gesamtproblem 

Es sei hier nochmals auf den wesentlichen Aspekt der Abhä von Teilproble-
men hingewiesen, welcher etwa bei Divide &amp; Conquer nicht Teil des Konzepts ist. 

16 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><head>.Lö haben. Das bedeutet, dass eine schlechte Lö durch kleine Adaptionen schnell zu einer sehr guten Lö werden kann. Da dies alleine noch nicht ausreicht um die notwendigen Kommissionierungstouren bereitzustellen, ist als weiterer Bestandteil die Berechnung von optimalen Touren notwendig. Zu diesem Zweck schien es aufgrund der eingrenzbaren Mö fü einzelne</head><label></label><figDesc></figDesc><table>Partitionierung vorhandener Bestellungen -Der erste Schritt soll aus al-
len vorhandenen Bestellungen jene auswä, die im Weiteren bearbeitet wer-
den. Dabei wird einerseits berü welche Prioritä eine Bestellung auf 
Basis ihres Liefertermins hat und andererseits welche Kapazitätsbeschrä-
gen in der Verdichtungszone vorherrschen. Es soll bereits durch diesen Schritt 
sichergestellt sein, dass Artikel aus einer Bestellung stets im selben Bereich der 
Verdichtungszone gelagert werden (siehe auch Kapitel 2). 

2. Berechnung von Artikelauswahlen -In einem zweiten Schritt werden dann 

23 die einzusammelnden Artikel in so genannte Artikelauswahlen zerlegt. Das heißt 
es werden Listen von Artikeln erstellt, die dazu dienen, die innerhalb einer 
Tour abzuarbeitenden Artikel zu definieren. Dieser Schritt wird durch eine VNS 
abgedeckt, die viele verschiedene solcher Artikelauswahlen erzeugt, um spä 
konkrete Touren daraus zu berechnen. 

3. Berechnung von Kommissionierungstouren -Wie bereits im vorange-
gangenen Schritt beschrieben, geht es hierbei um das Finden konkreter Tou-
ren durch das Lager. Fü jede einzelne Artikelauswahl kann nun mittels eines 
Dynamischen Programms sehr schnell die optimale Tour in Bezug auf deren 
Lä berechnet werden. Die Summe der Lä aller Touren stellt dabei die 
Gü der gesamten Lö in dieser Konstellation dar. Sobald dieser Schritt 
abgeschlossen ist, kann entschieden werden, ob das vorhandene Ergebnis an 
die Lagerarbeiterübergeben Lagerarbeiterü werden soll, oder nochmals zum vorigen Schritt 
zurü werden soll, um durch neue Artikelauswahlen ein mö-
weise besseres Gesamtergebnis erzielen zu kö. 

4. Zuweisen der Touren zu Arbeitern -Im letzten Schritt werden die vor-
handenen Touren an die verfü Lagerarbeiter vergeben. Hier wird wieder 
mittels einer weiteren VNS versucht eine mö optimale Aufteilung zu er-
reichen, damit die letzte Tour zum frü mö Zeitpunkt beendet werden 
kann. Sollten nach diesem Schritt noch weitere Bestellungen im System vor-
handen sein, beginnt einfach ein neuer kompletter Durchlauf des Algorithmus. 

Zur Veranschaulichung dieses Ablaufs dienen sowohl die schematische Darstellung in 
Abb. 6.1, als auch die Skizzierung durch Alg. 3. Dabei ist zu beachten, dass die Aus-
wertung der Zielfunktion des ersten Schritts abhä ist von den Berechnungen des 
zweiten Schritts, wodurch ein starkes Zusammenspiel dieser beiden Phasen gegeben 
ist. Das endgü Ergebnis aller Berechnungen soll allen verfü Arbeitern des 
Lagers Touren so zuweisen, dass der Endzeitpunkt aller Touren so frü wie mö 
ist. 

6.2 Variable Nachbarschaftssuche und Dynamische 
Programmierung 

Wie bereits erwä, handelt es sich bei dem Algorithmus um einen hybriden Ansatz, 
bestehend aus VNS und Dynamischer Programmierung. Dabei wird der durchsuchte 
Lö Lösungsraumü die zuvor angesprochene Einteilung in Artikelauswahlen definiert 
und dieser Schritt des Algorithmus auf Basis von VNS durchgefü. Ausgehend 
von einer ersten Auswahl werden also alle weiteren auf bessere Zielfunktionswerte 
hin untersuchten Artikelzusammenstellungen durch stete leichte Abä, defi-
niert durch das System an Nachbarschaften, generiert. Hierbei kann eine geringfü 
Verä einer Artikelzusammenstellung gleichzeitig große Auswirkungen auf die 6.2 Variable Nachbarschaftssuche und Dynamische Programmierung 

Bestellungen durch 
Kunden 
Partitionierung 
vorhandener 
Bestellungen 

! 

Berechnung von 
Artikelauswahlen 
Berechnung von 
Kommissionierungstouren 
Zuweisen der Touren 
zu Arbeitern 

Abbildung 6.1: Schematische Darstellung des grundsä Ablaufs 

Algorithmus 3 : Grundsä Algorithmus 
Input : Bestellungen mit Listen aller einzusammelnder Artikel 
Output : Eine Zuordnung von Arbeitern zu fertigen Touren 

begin 
repeat 

(1) 

Erstelle Partitionierung vorhandener Bestellungen ; 
repeat 

(2) 

Berechne Zuordnung von Artikeln zu Touren ; 

(3) 

Berechne optimale Touren fü die oben erstellte Zuordnung ; 
until keine Verbesserung konnte erzielt werden ; 

(4) 

Erstelle eine Zuordnung von Touren zu Arbeitern ; 
return die Zuordnung von Touren zu Arbeitern ; 
until keine weiteren Bestellungen sind abzuarbeiten ; 
end 

25 dadurch erhaltene Wegstrecken innerhalb des Lagers sinnvoll, mittels Dynamischer Program-
mierung nach einer Lö zu suchen. Dabei werden fü Auswahlen von zu besu-
chenden Lagergä optimale Teiltouren berechnet, auf deren Basis die kü 
Gesamttour erstellt werden kann. Die in Kapitel 6 beschriebene Struktur des in dieser Arbeit entwickelten Verfahrens 
verlangt nun noch nach einer konkretisierten Beschreibung. In diesem Kapitel mö 
ich nun die genaue Funktionsweise des Algorithmus vorstellen und im Detail auf die 
zuvor vorgestellten einzelnen Schritte eingehen. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><head></head><label></label><figDesc>vorgestellten Methode zur dynamischen Reihung vorzunehmen. Im Folgenden gilt es stets eine Permutation λ = (λ 1 , . . . , λ k ) der Nachbarschaftsstrukturen {N 1 , . . . , N k } zu berechnen, wobei der Nachbarschaftsstruktur N i , i = 1, . . . , k, ein Prä w i &gt; 0 zugeordnet wird, welches zu Beginn mit einem konstanten Wert W belegt wird. Wä nun die Nachbarschaft N λ i (x) einer Lö x durchsucht wird, wird w λ i in Abhä von Rechenzeit t λ i und Sucherfolg aktualisiert. Wurde eine verbesserte Lö gefunden, so wird w λ i halbiert und t λ i α hinzugefü, wobei α ein Parameter ist, der den Einfluss der Auswertung auf die eigentliche Rechenzeit reprä. Sollte keine bessere Lö gefunden werden, so wird die Nachbarschaftsstruktur durch Hinzufü der unverminderten Rechenzeit t λ i zum bestehenden Wert w λ i mit hö Kosten belastet. Die Permutation λ wird erst neu erzeugt, wenn ein gerade aktualisierter Wert w λ i kleiner als das bisher kleinste, min j=1,...,k w j , oder grö als das bisher grö, max j=1,...,k w j , solcher Prä ist. Dann wird anhand der aufsteigenden Werte w i eine neue Reihenfolge bestimmt.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><head>Tabelle 8 .2: Ergebnisse der Testlä 1 und 2 ohne Artikeln auf alternativen Lagerplä -Durchschnittswertë</head><label>8</label><figDesc></figDesc><table>In Ar f SS (x) 

S1 25 2135.47 

S2 25 2150.77 

S3 25 2368.25 

S4 25 2320.21 

S5 25 2352.01 

M1 50 3658.73 

M2 50 3908.69 

M3 50 4325.10 

M4 50 3886.14 

M5 50 4160.70 

L1 100 6461.82 

L2 100 6622.66 

L3 100 6581.63 

L4 100 6740.34 

L5 100 6560.45 

X1 200 10820.65 

X2 200 11049.59 

X3 200 10987.27 

X4 200 11011.98 

X5 200 11428.16 

f(x) 

75.2 
(4.74) 

68.6 
(8.27) 

68.5 
(7.02) 

66.3 
(3.53) 

statische Reihenfolge 

ohne Umkehren 

t 

C 

92.05 80.4 

81.05 72.5 

73.0 
(1.29) 108.64 85.6 

89.24 72.7 

82.75 78.2 

101.1 
(192.75) 921.98 99.3 

106.3 
(286.22) 791.38 99.2 

75.7 
(37.55) &gt;max 99.1 

94.5 
(174.52) &gt;max 99.8 

87.4 
(223.85) &gt;max 99.8 

84.0 
(146.84) &gt;max 99.5 

mit Umkehren 

f(x) 

72.6 
(2.22) 

67.4 
(8.19) 

70.2 
(3.37) 

68.0 
(1.04) 

63.4 
(6.85) 

225.1 
(433.63) 829.65 99.9 210.6 

133.8 
(258.82) 832.84 99.8 127.8 

196.8 
(1133.36) 974.95 99.8 179.1 

87.7 
(156.68) &gt;max 99.9 110.8 

104.8 
(303.67) &gt;max 99.8 115.3 

102.7 
(285.88) &gt;max 99.9 115.2 

129.1 
(332.14) &gt;max 99.9 148.6 

93.3 
(177.47) &gt;max 99.7 107.3 

114.9 
(258.96) &gt;max 100.0 122.5 

t 

Testlauf 1 

C 

119.63 87.1 

111.65 80.8 

135.41 85.6 

104.24 72.7 

92.97 83.7 

(520.43) 1117.14 99.9 

95.2 
(143.38) 1158.00 99.3 

(196.96) 1138.18 99.8 

93.4 
(191.30) 1133.87 99.2 

(889.70) 1189.09 99.8 

72.7 
(26.68) &gt;max 99.1 

(607.07) &gt;max 99.9 

95.0 
(142.52) &gt;max 99.8 

(310.36) &gt;max 99.8 

99.7 
(433.03) &gt;max 99.8 

(532.23) &gt;max 99.9 

93.8 
(344.94) &gt;max 99.5 

(531.30) &gt;max 99.9 

(372.87) &gt;max 99.7 

(591.60) &gt;max 100.0 

f(x) 

74.8 
(1.38) 

67.6 
(1.92) 

72.9 
(0.00) 

68.3 
(3.48) 

66.2 
(3.37) 

75.6 
(31.22) 

dynamische Reihenfolge 

ohne Umkehren 

t 

C 

105.77 80.6 

83.64 69.9 

119.23 85.6 

90.77 72.7 

103.56 78.1 

200.9 
(485.90) 649.32 99.9 

98.1 
(154.15) 638.38 99.3 

119.9 
(152.27) 660.23 99.8 

96.2 
(183.15) 685.06 99.2 

135.4 
(226.24) 651.23 99.8 

&gt;max 99.1 

81.5 
(173.85) &gt;max 99.9 

88.2 
(153.86) 1188.82 99.8 

95.2 
(196.42) &gt;max 99.8 

85.9 
(136.25) &gt;max 99.8 

104.3 
(507.35) &gt;max 99.9 

147.9 
(4458.14) &gt;max 99.5 

121.5 
(251.67) &gt;max 99.9 

109.9 
(1469.24) &gt;max 99.7 

116.0 
(703.96) &gt;max 100.0 

mit Umkehren 

f(x) 

72.5 
(1.27) 

66.6 
(0.64) 

70.1 
(1.19) 

67.8 
(0.66) 

63.1 
(2.56) 

189.0 
(411.04) 

87.4 
(126.26) 

118.0 
(149.04) 

101.7 
(230.13) 

71.2 
(13.48) 

81.6 
(157.74) 

82.1 
(179.97) 

102.1 
(307.57) 

79.6 
(180.27) 

100.0 
(358.40) 

t 

C 

156.23 86.1 

152.07 77.5 

148.48 85.6 

129.77 72.7 

146.03 84.0 

985.47 99.9 

957.56 99.3 

894.85 99.8 

947.45 99.2 

120.1 
(287.27) 1026.55 99.8 

&gt;max 99.1 

&gt;max 99.9 

&gt;max 99.8 

&gt;max 99.8 

&gt;max 99.8 

694.9 
(43803.86) &gt;max 96.8 

103.9 
(1926.03) &gt;max 99.5 

335.7 
(12189.38) &gt;max 99.8 

152.2 
(5119.61) &gt;max 99.7 

&gt;max 99.0 

ohne Umkehren 

f(x) 

74.7 
(0.88) 

67.3 
(0.56) 

70.9 
(0.00) 

67.6 
(0.00) 

66.1 
(0.63) 

77.7 
(41.05) 

70.9 
(49.67) 

73.8 
(40.10) 

72.0 
(68.85) 

71.7 
(36.90) 

81.9 
(54.59) 

80.3 
(51.32) 

83.3 
(66.47) 

t 

C 

300.90 86.9 

342.29 74.4 

270.27 86.2 

241.96 74.2 

286.96 85.2 

73.2 
(14.86) 1185.23 99.6 

71.9 
(9.54) 1151.07 99.0 

66.6 
(13.52) 1137.23 99.6 

68.2 
(13.04) 1153.65 99.0 

69.4 
(7.65) 1158.30 99.6 

&gt;max 99.0 

&gt;max 99.6 

&gt;max 99.6 

&gt;max 99.6 

&gt;max 99.6 

&gt;max 99.7 

&gt;max 99.3 

&gt;max 99.6 

100.3 
(1978.89) &gt;max 99.5 

127.4 
(5058.53) &gt;max 99.8 

uber 20 Testlä mit 25, 50, 
100 und 200 einzusammelnden Artikeln (Ar). Angefü sind der Zielfunktionswert (f(x) in Prozent [%]) relativ zur mittels S-Shape konstruierten 
Referenzlö (f SS (x)) und mit absoluter Standardabweichung in Klammern, die Laufzeit (t in Sekunden [s]) und die Kapazitä der 
Kommissionierungswagen (C in Prozent [%]). Getestet wurden die Instanzen (In) ohne Artikeln auf alternativen Lagerplä bei Berechnung mit 
und ohne Umkehren innerhalb eines Ganges und bei statischer und dynamischer Nachbarschaftsreihenfolge. 

Testlauf 2 

dynamische Reihenfolge 

mit Umkehren 

f(x) 

72.6 
(1.21) 

66.5 
(0.10) 

69.5 
(0.72) 

67.6 
(0.00) 

63.0 
(1.26) 

68.9 
(9.42) 

68.1 
(6.47) 

61.2 
(9.23) 

64.7 
(6.59) 

64.7 
(7.84) 

t 

C 

401.12 86.7 

420.56 79.2 

381.24 80.2 

299.53 68.2 

391.50 82.8 

&gt;max 99.6 

&gt;max 99.0 

&gt;max 99.6 

&gt;max 99.0 

&gt;max 99.6 

68.7 
(21.73) &gt;max 99.0 

66.5 
(46.18) &gt;max 99.6 

68.1 
(50.82) &gt;max 99.6 

67.4 
(43.64) &gt;max 99.6 

67.4 
(26.39) &gt;max 99.6 

382.8 
(23561.90) &gt;max 98.4 

118.7 
(5157.68) &gt;max 99.3 

72.9 
(65.01) &gt;max 99.6 

226.4 
(10815.91) &gt;max 99.5 

111.6 
(4570.83) &gt;max 99.1 konstruierten 

C 

t 

72.0 
(0.00) 
523.18 90.2 

66.2 
(0.85) 
498.57 78.2 

69.4 
(0.61) 
360.82 86.2 

67.6 
(0.00) 
325.90 74.2 

63.2 
(1.16) 
472.63 84.5 

69.2 
(10.27) 
&gt;max 99.6 

67.6 
(7.70) 
&gt;max 99.0 

62.1 
(9.11) 
&gt;max 99.6 

66.3 
(9.61) 
&gt;max 99.0 

64.8 
(9.14) 
&gt;max 99.6 

70.9 
(56.67) 
&gt;max 99.0 

66.2 
(26.12) 
&gt;max 99.6 

67.9 
(25.49) 
&gt;max 99.6 

67.3 
(46.97) 
&gt;max 99.6 

67.0 
(43.27) 
&gt;max 99.6 

141.1 
(7227.99) 
&gt;max 100.0 

108.5 
(3542.61) 
&gt;max 99.3 

418.9 
(12399.40) 
&gt;max 99.6 

116.6 
(4782.30) 
&gt;max 99.5 

125.5 
(5760.88) 
&gt;max 99.8 

¨ 
uber 20 Testlä mit 25, 50, 

f(x) 

Testlauf 2 

dynamische Reihenfolge 

mit Umkehren 

C 

t 

141.9 
(6124.02) 
&gt;max 99.6 

74.1 
(37.37) 
&gt;max 99.0 

70.0 
(25.04) 
&gt;max 99.6 

75.1 
(59.88) 
&gt;max 99.6 

71.8 
(73.46) 
&gt;max 99.6 

72.2 
(39.23) 
&gt;max 99.6 

82.5 
(55.80) 
&gt;max 99.7 

81.9 
(69.20) 
&gt;max 99.3 

83.6 
(70.99) 
&gt;max 99.5 

93.4 
(1284.40) 
&gt;max 99.8 

f(x) 

74.4 
(2.36) 
454.55 83.5 

67.3 
(0.92) 
360.31 74.8 

70.9 
(0.02) 
259.24 86.2 

67.6 
(0.00) 
250.91 74.2 

66.5 
(1.40) 
265.08 81.6 

72.7 
(14.80) 
1197.71 99.6 

71.2 
(8.86) 
1181.24 99.0 

66.8 
(10.71) 
1173.11 99.6 

70.3 
(11.14) 
1146.09 99.0 

68.9 
(12.12) 
1179.74 99.6 

C 

Artikeln auf alternativen Lagerplä bei Berechnung mit 

Nachbarschaftsreihenfolge. 

ohne Umkehren 

t 

mit Umkehren 

f(x) 

72.1 
(1.74) 
178.48 84.5 

66.2 
(0.97) 
143.19 74.6 

70.1 
(0.97) 
170.86 85.6 

67.8 
(0.73) 
134.27 72.7 

63.5 
(3.88) 
102.28 79.4 

191.1 
(396.50) 
911.15 99.9 

85.5 
(143.83) 
901.94 99.3 

106.5 
(132.44) 
973.31 99.8 

89.5 
(178.11) 
973.45 99.2 

128.1 
(210.22) 
1081.84 99.8 

71.0 
(22.46) 
&gt;max 99.1 

88.5 
(225.18) 
&gt;max 99.9 

84.0 
(170.39) 
&gt;max 99.8 

94.4 
(171.96) 
&gt;max 99.8 

78.0 
(163.04) 
&gt;max 99.8 

127.8 
(4345.26) 
&gt;max 99.9 

278.2 
(15585.21) 
&gt;max 99.5 

116.3 
(312.00) 
&gt;max 99.9 

202.8 
(10275.14) 
&gt;max 99.9 

142.0 
(4428.98) 
&gt;max 100.0 

C 

t 

und dynamischer 

73.0 
(1.26) 
92.90 85.6 

68.1 
(1.82) 
94.71 72.7 

66.7 
(2.68) 
91.48 78.1 

Testlauf 1 

dynamische Reihenfolge 

ohne Umkehren 

f(x) 

74.4 
(0.95) 
136.75 80.0 

67.5 
(1.41) 
117.70 70.2 

243.8 
(477.00) 
650.55 99.9 

92.3 
(108.51) 
797.88 99.3 

127.5 
(164.63) 
669.46 99.8 

95.0 
(163.61) 
669.68 99.2 

138.0 
(263.29) 
684.97 99.8 

75.4 
(20.19) 
1189.46 99.1 

83.9 
(148.72) 
1187.82 99.9 

88.9 
(140.42) 
&gt;max 99.8 

94.4 
(193.17) 
1199.49 99.8 

82.6 
(166.42) 
&gt;max 99.8 

101.1 
(474.02) 
&gt;max 99.9 

84.1 
(160.55) 
&gt;max 99.5 

123.9 
(301.01) 
&gt;max 99.9 

88.8 
(212.51) 
&gt;max 99.7 

106.5 
(320.98) 
&gt;max 100.0 

C 

t 

f(x) 

72.2 
(1.76) 
104.79 80.5 

66.8 
(6.82) 
91.76 73.3 

70.3 
(2.39) 
131.97 85.6 

67.9 
(0.99) 
122.70 72.7 

64.2 
(8.66) 
20.82 82.5 

200.4 
(461.85) 
1096.41 99.9 

99.8 
(179.04) 
1118.80 99.3 

123.8 
(288.40) 
1122.85 99.8 

107.1 
(226.38) 
1153.29 99.2 

169.6 
(688.33) 
1160.87 99.8 

71.7 
(25.18) 
&gt;max 99.1 

92.5 
(366.95) 
&gt;max 99.9 

93.9 
(255.14) 
&gt;max 99.8 

104.9 
(286.70) 
&gt;max 99.8 

91.1 
(262.57) 
&gt;max 99.8 

117.0 
(392.63) 
&gt;max 99.9 

86.0 
(296.29) 
&gt;max 99.5 

151.7 
(528.37) 
&gt;max 99.9 

98.5 
(291.13) 
&gt;max 99.7 

124.4 
(393.85) 
&gt;max 100.0 

statische Reihenfolge 

mit Umkehren 

C 

t 

ohne Umkehren 

f(x) 

74.8 
(5.23) 
62.30 76.9 

68.1 
(7.43) 
59.76 69.7 

72.9 
(0.95) 
111.35 85.6 

68.3 
(4.26) 
90.92 72.7 

67.8 
(9.99) 
20.82 79.3 

188.6 
(448.05) 
946.93 99.9 

104.7 
(141.95) 
804.04 99.3 

130.5 
(259.84) 
694.81 99.8 

108.6 
(228.32) 
945.89 99.2 

176.7 
(497.16) 
950.52 99.8 

75.5 
(33.27) 
&gt;max 99.1 

94.4 
(211.54) 
&gt;max 99.9 

88.1 
(147.70) 
&gt;max 99.8 

98.3 
(214.82) 
&gt;max 99.8 

84.5 
(188.72) 
&gt;max 99.8 

98.6 
(300.98) 
&gt;max 99.9 

86.9 
(207.66) 
&gt;max 99.5 

135.9 
(374.26) 
&gt;max 99.9 

94.3 
(208.04) 
&gt;max 99.7 

112.5 
(314.93) 
&gt;max 100.0 

SS (x) 

Tabelle 8.3: Ergebnisse der Testlä 1 und 2 mit 

Artikeln auf alternativen Lagerplä -Durchschnittswerte 

In Ar f 

M1 50 3658.73 

M2 50 3932.43 

M3 50 4256.39 

M4 50 3871.34 

M5 50 4160.70 

L1 100 6448.32 

L2 100 6548.31 

L3 100 6588.51 

L4 100 6740.34 

L5 100 6560.45 

X1 200 10925.71 

X2 200 10997.52 

X3 200 10932.39 

X4 200 11011.98 

X5 200 11360.11 

100 und 200 einzusammelnden Artikeln (Ar). Angefü sind der Zielfunktionswert (f(x) in Prozent [%]) relativ zur mittels S-Shape 

Referenzlö (f 
SS (x)) und mit absoluter Standardabweichung in Klammern, die Laufzeit (t in Sekunden [s]) und die Kapazitä der 
Kommissionierungswagen (C in Prozent [%]). Getestet wurden die Instanzen (In) mit 

und ohne 
Umkehren innerhalb eines Ganges und bei statischer 

S1 25 2147.27 

S2 25 2150.77 

S3 25 2368.25 

S4 25 2320.21 

S5 25 2310.23 

55 die Verwendung von dynamischen Nachbarschaftsreihenfolgen bessere Ergebnisse er-
warten und sollte wohl im Echtbetrieb bevorzugt verwendet werden. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14" validated="false"><head>Tabelle 8 .4: Effizienz der Nachbarschaften in Testlauf 1 ohne bzw. mit Artikeln auf alternativen Lagerplä -Durchschnittswertë ohne alternative Lagerplä mit alternativen Lagerplä In S1 S2 S3 S4 S5 S1 S2 S3 S4 S5</head><label>8</label><figDesc></figDesc><table>Ar 

ohne Umkehren 

N 1 N 2 N 3 

25 46.9 49.2 49.4 45.6 

25 44.0 46.1 60.8 37.2 

25 100.0 6.9 77.3 67.6 

25 100.0 15.6 71.6 58.2 

25 67.5 38.6 44.3 55.9 

M1 50 100.0 2.3 47.2 96.0 

M2 50 100.0 2.4 54.5 95.6 

M3 50 100.0 2.2 62.3 94.7 

M4 50 100.0 2.1 57.1 94.5 

M5 50 100.0 2.1 57.5 95.0 

L1 100 100.0 2.2 48.7 96.2 

L2 100 100.0 2.9 47.7 97.3 

L3 100 100.0 2.6 54.6 96.3 

L4 100 100.0 2.7 50.8 96.0 

L5 100 100.0 3.1 53.1 96.5 

X1 200 100.0 1.1 74.9 100.0 

X2 200 100.0 0.9 78.4 99.4 

X3 200 100.0 0.9 74.5 99.6 

X4 200 100.0 1.1 76.2 99.4 

X5 200 100.0 1.1 73.0 99.9 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18" validated="false"><head>). Angefü ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In) ohne bzw. mit Artikeln auf alternativen Lagerplä bei Berechnung mit und ohne Umkehren innerhalb eines</head><label></label><figDesc></figDesc><table>Ganges und bei statischer und 
dynamischer Nachbarschaftsreihenfolge. (N 1 : Split; N 2 : Merge; N 3 : Shift; N 4 : Swap; N 5 : SwapPosition; N 6 : SwapPositionMerge; N 7 : SplitPositionMerge; N 8 : DoubleShift.) 

N 4 N 5 N 6 N 7 N 8 

-50.1 

-48.6 

-39.3 

-51.1 

-42.8 

-28.9 

-34.0 

-40.6 

-34.6 

-35.6 

-55.4 

-55.9 

-58.4 

-62.2 

-63.0 

-94.9 

-91.5 

-97.4 

-90.7 

-91.4 

40.6 33.5 71.7 74.8 12.9 16.7 0.0 58.5 

41.3 36.1 79.9 69.5 10.9 16.6 0.0 62.3 

25 100.0 8.1 77.9 64.0 0.0 0.0 0.0 0.0 100.0 10.5 74.4 63.8 0.0 0.0 0.0 0.8 100.0 7.2 76.9 89.2 0.0 0.0 0.0 35.5 100.0 6.4 75.0 87.4 0.0 0.0 0.0 37.3 

97.8 14.7 76.9 82.1 0.0 0.0 0.0 47.6 

52.2 38.8 80.1 77.2 25.2 19.1 0.0 68.3 

99.6 1.0 87.5 98.1 74.0 72.3 0.0 66.8 

98.8 2.0 71.7 98.7 62.1 33.7 0.0 75.2 
L5 100 100.0 2.2 54.4 96.4 0.0 0.0 0.0 0.0 100.0 1.6 54.4 99.2 0.0 0.0 0.0 0.0 100.0 1.2 67.1 96.9 49.4 52.9 0.0 58.4 100.0 0.1 76.2 98.8 44.5 55.6 0.0 59.1 
X1 200 100.0 1.3 75.4 99.1 0.0 0.0 0.0 0.0 100.0 1.1 84.1 100.0 0.0 0.0 0.0 0.0 100.0 8.8 75.5 98.5 69.3 87.0 0.0 82.8 100.0 1.7 91.1 100.0 65.7 93.0 2.6 90.8 
X2 200 100.0 0.8 76.4 98.9 0.0 0.0 0.0 0.0 100.0 0.7 86.1 100.0 0.0 0.0 0.0 0.0 100.0 8.2 83.3 98.6 72.1 85.5 0.0 86.4 100.0 2.9 96.1 100.0 65.9 91.7 0.0 88.8 
X3 200 100.0 0.8 70.8 99.8 0.0 0.0 0.0 0.0 100.0 0.4 85.7 100.0 0.0 0.0 0.0 0.0 100.0 7.4 66.1 98.6 64.8 84.7 0.0 82.4 100.0 4.3 89.8 100.0 65.2 91.5 0.0 88.7 
X4 200 100.0 1.1 76.8 99.0 0.0 0.0 0.0 0.0 100.0 0.5 85.5 100.0 0.0 0.0 0.0 0.0 100.0 2.4 60.7 98.5 58.1 49.9 0.0 89.5 100.0 1.9 86.6 100.0 61.2 53.3 0.0 92.0 
X5 200 100.0 1.3 74.0 99.8 0.0 0.0 0.0 0.0 100.0 0.5 86.6 100.0 0.0 0.0 0.0 0.0 

99.0 18.9 68.5 98.9 88.0 99.1 0.0 92.1 100.0 24.2 83.4 100.0 80.7 99.6 0.0 95.6 

58 

</table></figure>

			<note place="foot" n="3"> max ), das Durchsuchen selbst ist wieder auf O(1) reduziert (siehe auch bei DoubleShift).</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Fazit</head><p>Inhalt dieser Arbeit war die Vorstellung eines hybriden Verfahrens, welches zum Lö von Problemen der Tourenplanung im Echtbetrieb eines Ersatzteillagers ein- gesetzt werden kann. Das Grundgerü bildet dabei eine Variable Nachbarschafts- suche mit integriertem Variable Neighborhood Descent (VND) als lokale Verbesse- rungsstrategie. Zum Lö von Teilproblemen innerhalb dieses Algorithmus wird ein eigens entwickeltes Dynamisches Programm verwendet, mit dessen Hilfe es mö ist, konkrete Touren optimal in polynomieller Zeit abhä von der Anzahl der be- stellten Artikel zu berechnen. Um abschließend eine Zuweisung von Lagerarbeitern zu den im vorhergehenden Schritt berechneten Touren zu berechnen, wird eine zweite VNS verwendet.</p><p>Aus den prä Ergebnissen der Tests lä sich ableiten, dass der gefunde- ne Ansatz prinzipiell funktionstü ist und schnell akzeptable Lö erzeugt. Sind die Arbeiter des Lagers erst einmal damit beschä den ersten ihnen zuge- wiesenen Artikel auszufassen, kann die Gesamtlö weiter optimiert werden. Dies ist mö, da zu jedem Zeitpunkt eine gü Lö verfü ist. Von Bedeu- tung ist dies eventuell auch, wenn eine Erweiterung des Verfahrens zu einem Online- Algorithmus durchgefü wird. Als solcher muss dieser auf laufend hinzukommende und im Vorhinein nicht bekannte Bestellungen reagieren kö. Die Adaptierung von bereits ausgegebenen Touren wü in so einem Algorithmus einen wesentlichen Beitrag zur Flexibilitä liefern. Dadurch, dass viele der zu liefernden Artikel erst im Laufe des Tages bestellt werden und zwischen den einzelnen Ausfassungsoperatio- nen der Lagerarbeiter entsprechend viel Berechnungszeit zur Verfü steht, wird die kontinuierliche Verbesserung einer anfangs schnell generierten Lö mö. Weiters scheint eine Aufteilung des Lagers inörtlichinö voneinander getrennte Berei- che, basierend auf der Lage der Verpackungszone, sinnvoll, wodurch die Grö der so entstehenden (Teil-)Instanzen entsprechend gering ist.</p><p>Obwohl die in dieser Arbeit prä Testergebnisse implizieren, dass die Grö der tatsä Instanzen mit bis zu 5000 bestellten Artikeln pro Tag zu kom- plex ist, kann man vermuten, dass nach weiterer¨Uberarbeitung und Erweiterung der Nachbarschaftsstrukturen oder Anpassungen der Durchsuchungsstrategie die Ergeb- nisse weiter verbessert und selbst Instanzen von solcher Grö qualitativ hochwertig gelö werden kö.</p><p>Leider war es im Rahmen dieser Arbeit nicht mö, die Auswirkungen von unvor- hergesehenen Vorkommnissen (ein Artikel ist nicht in gewü Menge verfü,</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Lösungsqualitä bei Verwendung zusä Nachbarschaften Tabelle 8.6: Effizienz der Nachbarschaften in Testlauf 2 ohne bzw. mit Artikeln auf alternativen Lagerplä-Durchschnittswertë uber 20 Testlä mit 25</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
		</imprint>
	</monogr>
	<note>100 und 200 einzusammelnden</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Angefü ist pro Nachbarschaft der prozentuelle Anteil (alle Werte in Prozent [%]) an erfolgreichen Schritten in Relation zu den insgesamt getesteten Schritten der jeweiligen Nachbarschaft. Getestet wurden die Instanzen (In) ohne bzw. mit Artikeln auf alternativen Lagerplä bei Berechnung mit Umkehren innerhalb eines Ganges und bei dynamischer Nachbarschaftsreihenfolge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Artikeln (ar</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>N 1 : Split; N 2 : Merge; N 3 : Shift; N 4 : Swap; N 5 : SwapPosition; N 6 : SwapPositionMerge; N 7 : SplitPositionMerge; N 8 : DoubleShift</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">The Traveling Salesman Problem: A Computational Study (Princeton Series in Applied Mathematics)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Applegate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Bixby</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Chvatal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Cook</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007-01" />
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A tabu search algorithm for the split delivery vehicle routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Archetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">G</forename><surname>Speranza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hertz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="64" to="73" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Dynamic Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Bellman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Dover Publications, Incorporated</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Design and control of warehouse order picking: A literature review</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Le-Duc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Roodbergen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">182</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="481" to="501" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Routing orderpickers in a warehouse: a comparison between optimal and heuristic solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Van Der</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Poort</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IIE Transactions</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="469" to="480" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A note on two problems in connexion with graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="269" to="271" />
			<date type="published" when="1959" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Savings by split delivery routing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dror</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Trudeau</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="141" to="145" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dror</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Trudeau</surname></persName>
		</author>
		<title level="m">Split delivery routing. Naval Research Logistics</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="383" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Generalized network design problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Feremans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Labbe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">148</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The symmetric generalized traveling salesman polytope</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fischetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Salazar Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="113" to="123" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A tutorial on variable neighborhood search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mladenovi´c</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C D</forename><surname>Gerad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">HEC Montreal and GERAD</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
<note type="report_type">Technical report</note>
	<note>Les Cahiers du GERAD</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Variable neighborhood search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mladenovi´c</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Metaheuristics</title>
		<editor>F. W. Glover and G. A. Kochenberger</editor>
		<imprint>
			<biblScope unit="page" from="145" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A tabu search heuristic for the vehicle routing problem with time windows and split deliveries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Haugland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Operations Research</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1947" to="1964" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Variable neighborhood descent with self-adaptive neighborhood-ordering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level Metaheuristics</title>
		<editor>C. Cotta, A. J. Fernandez, and J. E. Gallardo</editor>
		<meeting>the 7th EU/MEeting on Adaptive, Self-Adaptive, and Multi-Level Metaheuristics</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A new branch-and-cut algorithm for the capacitated vehicle routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lysgaard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">N</forename><surname>Letchford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Eglese</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Programming</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="423" to="445" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A variable neighborhood algorithm-a new metaheuristic for combinatorial optimization. Abstracts of papers presented at Optimization Days</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mladenovi´c</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page">112</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the capacitated vehicle routing problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ralphs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kopman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Pulleyblank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">T</forename><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Programming Series</title>
		<imprint>
			<biblScope unit="volume">94</biblScope>
			<biblScope unit="issue">B</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Vehicle Routing Problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Vigo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Monographs on Discrete Mathematics and Applications</title>
		<meeting><address><addrLine>SIAM, Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Heuristics for vehicle routing problem with time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">Q</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">H</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Windows, 6th AI and Math</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
